(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var vnode;
	var hasRequiredVnode;

	function requireVnode () {
		if (hasRequiredVnode) return vnode;
		hasRequiredVnode = 1;

		function Vnode(tag, key, attrs, children, text, dom) {
			return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}
		}
		Vnode.normalize = function(node) {
			if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
			if (node == null || typeof node === "boolean") return null
			if (typeof node === "object") return node
			return Vnode("#", undefined, undefined, String(node), undefined, undefined)
		};
		Vnode.normalizeChildren = function(input) {
			var children = [];
			if (input.length) {
				var isKeyed = input[0] != null && input[0].key != null;
				// Note: this is a *very* perf-sensitive check.
				// Fun fact: merging the loop like this is somehow faster than splitting
				// it, noticeably so.
				for (var i = 1; i < input.length; i++) {
					if ((input[i] != null && input[i].key != null) !== isKeyed) {
						throw new TypeError(
							isKeyed && (input[i] != null || typeof input[i] === "boolean")
								? "In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole."
								: "In fragments, vnodes must either all have keys or none have keys."
						)
					}
				}
				for (var i = 0; i < input.length; i++) {
					children[i] = Vnode.normalize(input[i]);
				}
			}
			return children
		};

		vnode = Vnode;
		return vnode;
	}

	var Vnode$4 = requireVnode();

	// Call via `hyperscriptVnode.apply(startOffset, arguments)`
	//
	// The reason I do it this way, forwarding the arguments and passing the start
	// offset in `this`, is so I don't have to create a temporary array in a
	// performance-critical path.
	//
	// In native ES6, I'd instead add a final `...args` parameter to the
	// `hyperscript` and `fragment` factories and define this as
	// `hyperscriptVnode(...args)`, since modern engines do optimize that away. But
	// ES5 (what Mithril.js requires thanks to IE support) doesn't give me that luxury,
	// and engines aren't nearly intelligent enough to do either of these:
	//
	// 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to
	//    another function only to be indexed.
	// 2. Elide an `arguments` allocation when it's passed to any function other
	//    than `Function.prototype.apply` or `Reflect.apply`.
	//
	// In ES6, it'd probably look closer to this (I'd need to profile it, though):
	// module.exports = function(attrs, ...children) {
	//     if (attrs == null || typeof attrs === "object" && attrs.tag == null && !Array.isArray(attrs)) {
	//         if (children.length === 1 && Array.isArray(children[0])) children = children[0]
	//     } else {
	//         children = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]
	//         attrs = undefined
	//     }
	//
	//     if (attrs == null) attrs = {}
	//     return Vnode("", attrs.key, attrs, children)
	// }
	var hyperscriptVnode$2 = function() {
		var attrs = arguments[this], start = this + 1, children;

		if (attrs == null) {
			attrs = {};
		} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = this;
		}

		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) children = [children];
		} else {
			children = [];
			while (start < arguments.length) children.push(arguments[start++]);
		}

		return Vnode$4("", attrs.key, attrs, children)
	};

	var hasOwn$2;
	var hasRequiredHasOwn;

	function requireHasOwn () {
		if (hasRequiredHasOwn) return hasOwn$2;
		hasRequiredHasOwn = 1;

		hasOwn$2 = {}.hasOwnProperty;
		return hasOwn$2;
	}

	var Vnode$3 = requireVnode();
	var hyperscriptVnode$1 = hyperscriptVnode$2;
	var hasOwn$1 = requireHasOwn();

	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};

	function isEmpty(object) {
		for (var key in object) if (hasOwn$1.call(object, key)) return false
		return true
	}

	function compileSelector(selector) {
		var match, tag = "div", classes = [], attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1], value = match[2];
			if (type === "" && value !== "") tag = value;
			else if (type === "#") attrs.id = value;
			else if (type === ".") classes.push(value);
			else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
				if (match[4] === "class") classes.push(attrValue);
				else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true;
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ");
		return selectorCache[selector] = {tag: tag, attrs: attrs}
	}

	function execSelector(state, vnode) {
		var attrs = vnode.attrs;
		var hasClass = hasOwn$1.call(attrs, "class");
		var className = hasClass ? attrs.class : attrs.className;

		vnode.tag = state.tag;
		vnode.attrs = {};

		if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
			var newAttrs = {};

			for (var key in attrs) {
				if (hasOwn$1.call(attrs, key)) newAttrs[key] = attrs[key];
			}

			attrs = newAttrs;
		}

		for (var key in state.attrs) {
			if (hasOwn$1.call(state.attrs, key) && key !== "className" && !hasOwn$1.call(attrs, key)){
				attrs[key] = state.attrs[key];
			}
		}
		if (className != null || state.attrs.className != null) attrs.className =
			className != null
				? state.attrs.className != null
					? String(state.attrs.className) + " " + String(className)
					: className
				: state.attrs.className != null
					? state.attrs.className
					: null;

		if (hasClass) attrs.class = null;

		for (var key in attrs) {
			if (hasOwn$1.call(attrs, key) && key !== "key") {
				vnode.attrs = attrs;
				break
			}
		}

		return vnode
	}

	function hyperscript$2(selector) {
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}

		var vnode = hyperscriptVnode$1.apply(1, arguments);

		if (typeof selector === "string") {
			vnode.children = Vnode$3.normalizeChildren(vnode.children);
			if (selector !== "[") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)
		}

		vnode.tag = selector;
		return vnode
	}

	var hyperscript_1$1 = hyperscript$2;

	var Vnode$2 = requireVnode();

	var trust = function(html) {
		if (html == null) html = "";
		return Vnode$2("<", undefined, undefined, html, undefined, undefined)
	};

	var Vnode$1 = requireVnode();
	var hyperscriptVnode = hyperscriptVnode$2;

	var fragment = function() {
		var vnode = hyperscriptVnode.apply(0, arguments);

		vnode.tag = "[";
		vnode.children = Vnode$1.normalizeChildren(vnode.children);
		return vnode
	};

	var hyperscript$1 = hyperscript_1$1;

	hyperscript$1.trust = trust;
	hyperscript$1.fragment = fragment;

	var hyperscript_1 = hyperscript$1;

	var promise = {exports: {}};

	var polyfill;
	var hasRequiredPolyfill;

	function requirePolyfill () {
		if (hasRequiredPolyfill) return polyfill;
		hasRequiredPolyfill = 1;
		/** @constructor */
		var PromisePolyfill = function(executor) {
			if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with 'new'.")
			if (typeof executor !== "function") throw new TypeError("executor must be a function.")

			var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false);
			var instance = self._instance = {resolvers: resolvers, rejectors: rejectors};
			var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
			function handler(list, shouldAbsorb) {
				return function execute(value) {
					var then;
					try {
						if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
							if (value === self) throw new TypeError("Promise can't be resolved with itself.")
							executeOnce(then.bind(value));
						}
						else {
							callAsync(function() {
								if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
								for (var i = 0; i < list.length; i++) list[i](value);
								resolvers.length = 0, rejectors.length = 0;
								instance.state = shouldAbsorb;
								instance.retry = function() {execute(value);};
							});
						}
					}
					catch (e) {
						rejectCurrent(e);
					}
				}
			}
			function executeOnce(then) {
				var runs = 0;
				function run(fn) {
					return function(value) {
						if (runs++ > 0) return
						fn(value);
					}
				}
				var onerror = run(rejectCurrent);
				try {then(run(resolveCurrent), onerror);} catch (e) {onerror(e);}
			}

			executeOnce(executor);
		};
		PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
			var self = this, instance = self._instance;
			function handle(callback, list, next, state) {
				list.push(function(value) {
					if (typeof callback !== "function") next(value);
					else try {resolveNext(callback(value));} catch (e) {if (rejectNext) rejectNext(e);}
				});
				if (typeof instance.retry === "function" && state === instance.state) instance.retry();
			}
			var resolveNext, rejectNext;
			var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject;});
			handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
			return promise
		};
		PromisePolyfill.prototype.catch = function(onRejection) {
			return this.then(null, onRejection)
		};
		PromisePolyfill.prototype.finally = function(callback) {
			return this.then(
				function(value) {
					return PromisePolyfill.resolve(callback()).then(function() {
						return value
					})
				},
				function(reason) {
					return PromisePolyfill.resolve(callback()).then(function() {
						return PromisePolyfill.reject(reason);
					})
				}
			)
		};
		PromisePolyfill.resolve = function(value) {
			if (value instanceof PromisePolyfill) return value
			return new PromisePolyfill(function(resolve) {resolve(value);})
		};
		PromisePolyfill.reject = function(value) {
			return new PromisePolyfill(function(resolve, reject) {reject(value);})
		};
		PromisePolyfill.all = function(list) {
			return new PromisePolyfill(function(resolve, reject) {
				var total = list.length, count = 0, values = [];
				if (list.length === 0) resolve([]);
				else for (var i = 0; i < list.length; i++) {
					(function(i) {
						function consume(value) {
							count++;
							values[i] = value;
							if (count === total) resolve(values);
						}
						if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
							list[i].then(consume, reject);
						}
						else consume(list[i]);
					})(i);
				}
			})
		};
		PromisePolyfill.race = function(list) {
			return new PromisePolyfill(function(resolve, reject) {
				for (var i = 0; i < list.length; i++) {
					list[i].then(resolve, reject);
				}
			})
		};

		polyfill = PromisePolyfill;
		return polyfill;
	}

	/* global window */

	var PromisePolyfill$1 = requirePolyfill();

	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") {
			window.Promise = PromisePolyfill$1;
		} else if (!window.Promise.prototype.finally) {
			window.Promise.prototype.finally = PromisePolyfill$1.prototype.finally;
		}
		promise.exports = window.Promise;
	} else if (typeof commonjsGlobal !== "undefined") {
		if (typeof commonjsGlobal.Promise === "undefined") {
			commonjsGlobal.Promise = PromisePolyfill$1;
		} else if (!commonjsGlobal.Promise.prototype.finally) {
			commonjsGlobal.Promise.prototype.finally = PromisePolyfill$1.prototype.finally;
		}
		promise.exports = commonjsGlobal.Promise;
	} else {
		promise.exports = PromisePolyfill$1;
	}

	var promiseExports = promise.exports;

	var render$2;
	var hasRequiredRender$1;

	function requireRender$1 () {
		if (hasRequiredRender$1) return render$2;
		hasRequiredRender$1 = 1;

		var Vnode = requireVnode();

		render$2 = function($window) {
			var $doc = $window && $window.document;
			var currentRedraw;

			var nameSpace = {
				svg: "http://www.w3.org/2000/svg",
				math: "http://www.w3.org/1998/Math/MathML"
			};

			function getNameSpace(vnode) {
				return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
			}

			//sanity check to discourage people from doing `vnode.state = ...`
			function checkState(vnode, original) {
				if (vnode.state !== original) throw new Error("'vnode.state' must not be modified.")
			}

			//Note: the hook is passed as the `this` argument to allow proxying the
			//arguments without requiring a full array allocation to do so. It also
			//takes advantage of the fact the current `vnode` is the first argument in
			//all lifecycle methods.
			function callHook(vnode) {
				var original = vnode.state;
				try {
					return this.apply(original, arguments)
				} finally {
					checkState(vnode, original);
				}
			}

			// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when
			// inside an iframe. Catch and swallow this error, and heavy-handidly return null.
			function activeElement() {
				try {
					return $doc.activeElement
				} catch (e) {
					return null
				}
			}
			//create
			function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
				for (var i = start; i < end; i++) {
					var vnode = vnodes[i];
					if (vnode != null) {
						createNode(parent, vnode, hooks, ns, nextSibling);
					}
				}
			}
			function createNode(parent, vnode, hooks, ns, nextSibling) {
				var tag = vnode.tag;
				if (typeof tag === "string") {
					vnode.state = {};
					if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
					switch (tag) {
						case "#": createText(parent, vnode, nextSibling); break
						case "<": createHTML(parent, vnode, ns, nextSibling); break
						case "[": createFragment(parent, vnode, hooks, ns, nextSibling); break
						default: createElement(parent, vnode, hooks, ns, nextSibling);
					}
				}
				else createComponent(parent, vnode, hooks, ns, nextSibling);
			}
			function createText(parent, vnode, nextSibling) {
				vnode.dom = $doc.createTextNode(vnode.children);
				insertNode(parent, vnode.dom, nextSibling);
			}
			var possibleParents = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"};
			function createHTML(parent, vnode, ns, nextSibling) {
				var match = vnode.children.match(/^\s*?<(\w+)/im) || [];
				// not using the proper parent makes the child element(s) vanish.
				//     var div = document.createElement("div")
				//     div.innerHTML = "<td>i</td><td>j</td>"
				//     console.log(div.innerHTML)
				// --> "ij", no <td> in sight.
				var temp = $doc.createElement(possibleParents[match[1]] || "div");
				if (ns === "http://www.w3.org/2000/svg") {
					temp.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\">" + vnode.children + "</svg>";
					temp = temp.firstChild;
				} else {
					temp.innerHTML = vnode.children;
				}
				vnode.dom = temp.firstChild;
				vnode.domSize = temp.childNodes.length;
				// Capture nodes to remove, so we don't confuse them.
				vnode.instance = [];
				var fragment = $doc.createDocumentFragment();
				var child;
				while (child = temp.firstChild) {
					vnode.instance.push(child);
					fragment.appendChild(child);
				}
				insertNode(parent, fragment, nextSibling);
			}
			function createFragment(parent, vnode, hooks, ns, nextSibling) {
				var fragment = $doc.createDocumentFragment();
				if (vnode.children != null) {
					var children = vnode.children;
					createNodes(fragment, children, 0, children.length, hooks, null, ns);
				}
				vnode.dom = fragment.firstChild;
				vnode.domSize = fragment.childNodes.length;
				insertNode(parent, fragment, nextSibling);
			}
			function createElement(parent, vnode, hooks, ns, nextSibling) {
				var tag = vnode.tag;
				var attrs = vnode.attrs;
				var is = attrs && attrs.is;

				ns = getNameSpace(vnode) || ns;

				var element = ns ?
					is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
					is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag);
				vnode.dom = element;

				if (attrs != null) {
					setAttrs(vnode, attrs, ns);
				}

				insertNode(parent, element, nextSibling);

				if (!maybeSetContentEditable(vnode)) {
					if (vnode.children != null) {
						var children = vnode.children;
						createNodes(element, children, 0, children.length, hooks, null, ns);
						if (vnode.tag === "select" && attrs != null) setLateSelectAttrs(vnode, attrs);
					}
				}
			}
			function initComponent(vnode, hooks) {
				var sentinel;
				if (typeof vnode.tag.view === "function") {
					vnode.state = Object.create(vnode.tag);
					sentinel = vnode.state.view;
					if (sentinel.$$reentrantLock$$ != null) return
					sentinel.$$reentrantLock$$ = true;
				} else {
					vnode.state = void 0;
					sentinel = vnode.tag;
					if (sentinel.$$reentrantLock$$ != null) return
					sentinel.$$reentrantLock$$ = true;
					vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode);
				}
				initLifecycle(vnode.state, vnode, hooks);
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
				vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
				sentinel.$$reentrantLock$$ = null;
			}
			function createComponent(parent, vnode, hooks, ns, nextSibling) {
				initComponent(vnode, hooks);
				if (vnode.instance != null) {
					createNode(parent, vnode.instance, hooks, ns, nextSibling);
					vnode.dom = vnode.instance.dom;
					vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
				}
				else {
					vnode.domSize = 0;
				}
			}

			//update
			/**
			 * @param {Element|Fragment} parent - the parent element
			 * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for
			 *                               this part of the tree
			 * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.
			 * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)
			 * @param {Element | null} nextSibling - the next DOM node if we're dealing with a
			 *                                       fragment that is not the last item in its
			 *                                       parent
			 * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any
			 * @returns void
			 */
			// This function diffs and patches lists of vnodes, both keyed and unkeyed.
			//
			// We will:
			//
			// 1. describe its general structure
			// 2. focus on the diff algorithm optimizations
			// 3. discuss DOM node operations.

			// ## Overview:
			//
			// The updateNodes() function:
			// - deals with trivial cases
			// - determines whether the lists are keyed or unkeyed based on the first non-null node
			//   of each list.
			// - diffs them and patches the DOM if needed (that's the brunt of the code)
			// - manages the leftovers: after diffing, are there:
			//   - old nodes left to remove?
			// 	 - new nodes to insert?
			// 	 deal with them!
			//
			// The lists are only iterated over once, with an exception for the nodes in `old` that
			// are visited in the fourth part of the diff and in the `removeNodes` loop.

			// ## Diffing
			//
			// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837
			// may be good for context on longest increasing subsequence-based logic for moving nodes.
			//
			// In order to diff keyed lists, one has to
			//
			// 1) match nodes in both lists, per key, and update them accordingly
			// 2) create the nodes present in the new list, but absent in the old one
			// 3) remove the nodes present in the old list, but absent in the new one
			// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.
			//
			// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate
			// over the new list and for each new vnode, find the corresponding vnode in the old list using
			// the map.
			// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new
			// and must be created.
			// For the removals, we actually remove the nodes that have been updated from the old list.
			// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.
			// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)
			// algorithm.
			//
			// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going
			// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices
			// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would
			//  match the above lists, for example).
			//
			// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We
			// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.
			//
			// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually
			// the longest increasing subsequence *of old nodes still present in the new list*).
			//
			// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation
			// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,
			// the `LIS` and a temporary one to create the LIS).
			//
			// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of
			// the LIS and can be updated without moving them.
			//
			// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with
			// the exception of the last node if the list is fully reversed).
			//
			// ## Finding the next sibling.
			//
			// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.
			// When the list is being traversed top-down, at any index, the DOM nodes up to the previous
			// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old
			// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.
			//
			// In the other scenarios (swaps, upwards traversal, map-based diff),
			// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the
			// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node
			// as the next sibling (cached in the `nextSibling` variable).


			// ## DOM node moves
			//
			// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,
			// this is not the case if the node moved (second and fourth part of the diff algo). We move
			// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`
			// variable rather than fetching it using `getNextSibling()`.
			//
			// The fourth part of the diff currently inserts nodes unconditionally, leading to issues
			// like #1791 and #1999. We need to be smarter about those situations where adjascent old
			// nodes remain together in the new list in a way that isn't covered by parts one and
			// three of the diff algo.

			function updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {
				if (old === vnodes || old == null && vnodes == null) return
				else if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns);
				else if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length);
				else {
					var isOldKeyed = old[0] != null && old[0].key != null;
					var isKeyed = vnodes[0] != null && vnodes[0].key != null;
					var start = 0, oldStart = 0;
					if (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++;
					if (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++;
					if (isOldKeyed !== isKeyed) {
						removeNodes(parent, old, oldStart, old.length);
						createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns);
					} else if (!isKeyed) {
						// Don't index past the end of either list (causes deopts).
						var commonLength = old.length < vnodes.length ? old.length : vnodes.length;
						// Rewind if necessary to the first non-null index on either side.
						// We could alternatively either explicitly create or remove nodes when `start !== oldStart`
						// but that would be optimizing for sparse lists which are more rare than dense ones.
						start = start < oldStart ? start : oldStart;
						for (; start < commonLength; start++) {
							o = old[start];
							v = vnodes[start];
							if (o === v || o == null && v == null) continue
							else if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling));
							else if (v == null) removeNode(parent, o);
							else updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns);
						}
						if (old.length > commonLength) removeNodes(parent, old, start, old.length);
						if (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns);
					} else {
						// keyed diff
						var oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling;

						// bottom-up
						while (oldEnd >= oldStart && end >= start) {
							oe = old[oldEnd];
							ve = vnodes[end];
							if (oe.key !== ve.key) break
							if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns);
							if (ve.dom != null) nextSibling = ve.dom;
							oldEnd--, end--;
						}
						// top-down
						while (oldEnd >= oldStart && end >= start) {
							o = old[oldStart];
							v = vnodes[start];
							if (o.key !== v.key) break
							oldStart++, start++;
							if (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns);
						}
						// swaps and list reversals
						while (oldEnd >= oldStart && end >= start) {
							if (start === end) break
							if (o.key !== ve.key || oe.key !== v.key) break
							topSibling = getNextSibling(old, oldStart, nextSibling);
							moveNodes(parent, oe, topSibling);
							if (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns);
							if (++start <= --end) moveNodes(parent, o, nextSibling);
							if (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns);
							if (ve.dom != null) nextSibling = ve.dom;
							oldStart++; oldEnd--;
							oe = old[oldEnd];
							ve = vnodes[end];
							o = old[oldStart];
							v = vnodes[start];
						}
						// bottom up once again
						while (oldEnd >= oldStart && end >= start) {
							if (oe.key !== ve.key) break
							if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns);
							if (ve.dom != null) nextSibling = ve.dom;
							oldEnd--, end--;
							oe = old[oldEnd];
							ve = vnodes[end];
						}
						if (start > end) removeNodes(parent, old, oldStart, oldEnd + 1);
						else if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
						else {
							// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul
							var originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices;
							for (i = 0; i < vnodesLength; i++) oldIndices[i] = -1;
							for (i = end; i >= start; i--) {
								if (map == null) map = getKeyMap(old, oldStart, oldEnd + 1);
								ve = vnodes[i];
								var oldIndex = map[ve.key];
								if (oldIndex != null) {
									pos = (oldIndex < pos) ? oldIndex : -1; // becomes -1 if nodes were re-ordered
									oldIndices[i-start] = oldIndex;
									oe = old[oldIndex];
									old[oldIndex] = null;
									if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns);
									if (ve.dom != null) nextSibling = ve.dom;
									matched++;
								}
							}
							nextSibling = originalNextSibling;
							if (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1);
							if (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
							else {
								if (pos === -1) {
									// the indices of the indices of the items that are part of the
									// longest increasing subsequence in the oldIndices list
									lisIndices = makeLisIndices(oldIndices);
									li = lisIndices.length - 1;
									for (i = end; i >= start; i--) {
										v = vnodes[i];
										if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling);
										else {
											if (lisIndices[li] === i - start) li--;
											else moveNodes(parent, v, nextSibling);
										}
										if (v.dom != null) nextSibling = vnodes[i].dom;
									}
								} else {
									for (i = end; i >= start; i--) {
										v = vnodes[i];
										if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling);
										if (v.dom != null) nextSibling = vnodes[i].dom;
									}
								}
							}
						}
					}
				}
			}
			function updateNode(parent, old, vnode, hooks, nextSibling, ns) {
				var oldTag = old.tag, tag = vnode.tag;
				if (oldTag === tag) {
					vnode.state = old.state;
					vnode.events = old.events;
					if (shouldNotUpdate(vnode, old)) return
					if (typeof oldTag === "string") {
						if (vnode.attrs != null) {
							updateLifecycle(vnode.attrs, vnode, hooks);
						}
						switch (oldTag) {
							case "#": updateText(old, vnode); break
							case "<": updateHTML(parent, old, vnode, ns, nextSibling); break
							case "[": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break
							default: updateElement(old, vnode, hooks, ns);
						}
					}
					else updateComponent(parent, old, vnode, hooks, nextSibling, ns);
				}
				else {
					removeNode(parent, old);
					createNode(parent, vnode, hooks, ns, nextSibling);
				}
			}
			function updateText(old, vnode) {
				if (old.children.toString() !== vnode.children.toString()) {
					old.dom.nodeValue = vnode.children;
				}
				vnode.dom = old.dom;
			}
			function updateHTML(parent, old, vnode, ns, nextSibling) {
				if (old.children !== vnode.children) {
					removeHTML(parent, old);
					createHTML(parent, vnode, ns, nextSibling);
				}
				else {
					vnode.dom = old.dom;
					vnode.domSize = old.domSize;
					vnode.instance = old.instance;
				}
			}
			function updateFragment(parent, old, vnode, hooks, nextSibling, ns) {
				updateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns);
				var domSize = 0, children = vnode.children;
				vnode.dom = null;
				if (children != null) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null && child.dom != null) {
							if (vnode.dom == null) vnode.dom = child.dom;
							domSize += child.domSize || 1;
						}
					}
					if (domSize !== 1) vnode.domSize = domSize;
				}
			}
			function updateElement(old, vnode, hooks, ns) {
				var element = vnode.dom = old.dom;
				ns = getNameSpace(vnode) || ns;

				if (vnode.tag === "textarea") {
					if (vnode.attrs == null) vnode.attrs = {};
				}
				updateAttrs(vnode, old.attrs, vnode.attrs, ns);
				if (!maybeSetContentEditable(vnode)) {
					updateNodes(element, old.children, vnode.children, hooks, null, ns);
				}
			}
			function updateComponent(parent, old, vnode, hooks, nextSibling, ns) {
				vnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode));
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
				updateLifecycle(vnode.state, vnode, hooks);
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
				if (vnode.instance != null) {
					if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);
					else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns);
					vnode.dom = vnode.instance.dom;
					vnode.domSize = vnode.instance.domSize;
				}
				else if (old.instance != null) {
					removeNode(parent, old.instance);
					vnode.dom = undefined;
					vnode.domSize = 0;
				}
				else {
					vnode.dom = old.dom;
					vnode.domSize = old.domSize;
				}
			}
			function getKeyMap(vnodes, start, end) {
				var map = Object.create(null);
				for (; start < end; start++) {
					var vnode = vnodes[start];
					if (vnode != null) {
						var key = vnode.key;
						if (key != null) map[key] = start;
					}
				}
				return map
			}
			// Lifted from ivi https://github.com/ivijs/ivi/
			// takes a list of unique numbers (-1 is special and can
			// occur multiple times) and returns an array with the indices
			// of the items that are part of the longest increasing
			// subsequence
			var lisTemp = [];
			function makeLisIndices(a) {
				var result = [0];
				var u = 0, v = 0, i = 0;
				var il = lisTemp.length = a.length;
				for (var i = 0; i < il; i++) lisTemp[i] = a[i];
				for (var i = 0; i < il; ++i) {
					if (a[i] === -1) continue
					var j = result[result.length - 1];
					if (a[j] < a[i]) {
						lisTemp[i] = j;
						result.push(i);
						continue
					}
					u = 0;
					v = result.length - 1;
					while (u < v) {
						// Fast integer average without overflow.
						// eslint-disable-next-line no-bitwise
						var c = (u >>> 1) + (v >>> 1) + (u & v & 1);
						if (a[result[c]] < a[i]) {
							u = c + 1;
						}
						else {
							v = c;
						}
					}
					if (a[i] < a[result[u]]) {
						if (u > 0) lisTemp[i] = result[u - 1];
						result[u] = i;
					}
				}
				u = result.length;
				v = result[u - 1];
				while (u-- > 0) {
					result[u] = v;
					v = lisTemp[v];
				}
				lisTemp.length = 0;
				return result
			}

			function getNextSibling(vnodes, i, nextSibling) {
				for (; i < vnodes.length; i++) {
					if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
				}
				return nextSibling
			}

			// This covers a really specific edge case:
			// - Parent node is keyed and contains child
			// - Child is removed, returns unresolved promise in `onbeforeremove`
			// - Parent node is moved in keyed diff
			// - Remaining children still need moved appropriately
			//
			// Ideally, I'd track removed nodes as well, but that introduces a lot more
			// complexity and I'm not exactly interested in doing that.
			function moveNodes(parent, vnode, nextSibling) {
				var frag = $doc.createDocumentFragment();
				moveChildToFrag(parent, frag, vnode);
				insertNode(parent, frag, nextSibling);
			}
			function moveChildToFrag(parent, frag, vnode) {
				// Dodge the recursion overhead in a few of the most common cases.
				while (vnode.dom != null && vnode.dom.parentNode === parent) {
					if (typeof vnode.tag !== "string") {
						vnode = vnode.instance;
						if (vnode != null) continue
					} else if (vnode.tag === "<") {
						for (var i = 0; i < vnode.instance.length; i++) {
							frag.appendChild(vnode.instance[i]);
						}
					} else if (vnode.tag !== "[") {
						// Don't recurse for text nodes *or* elements, just fragments
						frag.appendChild(vnode.dom);
					} else if (vnode.children.length === 1) {
						vnode = vnode.children[0];
						if (vnode != null) continue
					} else {
						for (var i = 0; i < vnode.children.length; i++) {
							var child = vnode.children[i];
							if (child != null) moveChildToFrag(parent, frag, child);
						}
					}
					break
				}
			}

			function insertNode(parent, dom, nextSibling) {
				if (nextSibling != null) parent.insertBefore(dom, nextSibling);
				else parent.appendChild(dom);
			}

			function maybeSetContentEditable(vnode) {
				if (vnode.attrs == null || (
					vnode.attrs.contenteditable == null && // attribute
					vnode.attrs.contentEditable == null // property
				)) return false
				var children = vnode.children;
				if (children != null && children.length === 1 && children[0].tag === "<") {
					var content = children[0].children;
					if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
				}
				else if (children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted.")
				return true
			}

			//remove
			function removeNodes(parent, vnodes, start, end) {
				for (var i = start; i < end; i++) {
					var vnode = vnodes[i];
					if (vnode != null) removeNode(parent, vnode);
				}
			}
			function removeNode(parent, vnode) {
				var mask = 0;
				var original = vnode.state;
				var stateResult, attrsResult;
				if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeremove === "function") {
					var result = callHook.call(vnode.state.onbeforeremove, vnode);
					if (result != null && typeof result.then === "function") {
						mask = 1;
						stateResult = result;
					}
				}
				if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
					var result = callHook.call(vnode.attrs.onbeforeremove, vnode);
					if (result != null && typeof result.then === "function") {
						// eslint-disable-next-line no-bitwise
						mask |= 2;
						attrsResult = result;
					}
				}
				checkState(vnode, original);

				// If we can, try to fast-path it and avoid all the overhead of awaiting
				if (!mask) {
					onremove(vnode);
					removeChild(parent, vnode);
				} else {
					if (stateResult != null) {
						var next = function () {
							// eslint-disable-next-line no-bitwise
							if (mask & 1) { mask &= 2; if (!mask) reallyRemove(); }
						};
						stateResult.then(next, next);
					}
					if (attrsResult != null) {
						var next = function () {
							// eslint-disable-next-line no-bitwise
							if (mask & 2) { mask &= 1; if (!mask) reallyRemove(); }
						};
						attrsResult.then(next, next);
					}
				}

				function reallyRemove() {
					checkState(vnode, original);
					onremove(vnode);
					removeChild(parent, vnode);
				}
			}
			function removeHTML(parent, vnode) {
				for (var i = 0; i < vnode.instance.length; i++) {
					parent.removeChild(vnode.instance[i]);
				}
			}
			function removeChild(parent, vnode) {
				// Dodge the recursion overhead in a few of the most common cases.
				while (vnode.dom != null && vnode.dom.parentNode === parent) {
					if (typeof vnode.tag !== "string") {
						vnode = vnode.instance;
						if (vnode != null) continue
					} else if (vnode.tag === "<") {
						removeHTML(parent, vnode);
					} else {
						if (vnode.tag !== "[") {
							parent.removeChild(vnode.dom);
							if (!Array.isArray(vnode.children)) break
						}
						if (vnode.children.length === 1) {
							vnode = vnode.children[0];
							if (vnode != null) continue
						} else {
							for (var i = 0; i < vnode.children.length; i++) {
								var child = vnode.children[i];
								if (child != null) removeChild(parent, child);
							}
						}
					}
					break
				}
			}
			function onremove(vnode) {
				if (typeof vnode.tag !== "string" && typeof vnode.state.onremove === "function") callHook.call(vnode.state.onremove, vnode);
				if (vnode.attrs && typeof vnode.attrs.onremove === "function") callHook.call(vnode.attrs.onremove, vnode);
				if (typeof vnode.tag !== "string") {
					if (vnode.instance != null) onremove(vnode.instance);
				} else {
					var children = vnode.children;
					if (Array.isArray(children)) {
						for (var i = 0; i < children.length; i++) {
							var child = children[i];
							if (child != null) onremove(child);
						}
					}
				}
			}

			//attrs
			function setAttrs(vnode, attrs, ns) {
				// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
				//
				// Also, the DOM does things to inputs based on the value, so it needs set first.
				// See: https://github.com/MithrilJS/mithril.js/issues/2622
				if (vnode.tag === "input" && attrs.type != null) vnode.dom.setAttribute("type", attrs.type);
				var isFileInput = attrs != null && vnode.tag === "input" && attrs.type === "file";
				for (var key in attrs) {
					setAttr(vnode, key, null, attrs[key], ns, isFileInput);
				}
			}
			function setAttr(vnode, key, old, value, ns, isFileInput) {
				if (key === "key" || key === "is" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object" || key === "type" && vnode.tag === "input") return
				if (key[0] === "o" && key[1] === "n") return updateEvent(vnode, key, value)
				if (key.slice(0, 6) === "xlink:") vnode.dom.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(6), value);
				else if (key === "style") updateStyle(vnode.dom, old, value);
				else if (hasPropertyKey(vnode, key, ns)) {
					if (key === "value") {
						// Only do the coercion if we're actually going to check the value.
						/* eslint-disable no-implicit-coercion */
						//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
						//setting input[type=file][value] to same value causes an error to be generated if it's non-empty
						if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === "" + value && (isFileInput || vnode.dom === activeElement())) return
						//setting select[value] to same value while having select open blinks select dropdown in Chrome
						if (vnode.tag === "select" && old !== null && vnode.dom.value === "" + value) return
						//setting option[value] to same value while having select open blinks select dropdown in Chrome
						if (vnode.tag === "option" && old !== null && vnode.dom.value === "" + value) return
						//setting input[type=file][value] to different value is an error if it's non-empty
						// Not ideal, but it at least works around the most common source of uncaught exceptions for now.
						if (isFileInput && "" + value !== "") { console.error("`value` is read-only on file inputs!"); return }
						/* eslint-enable no-implicit-coercion */
					}
					vnode.dom[key] = value;
				} else {
					if (typeof value === "boolean") {
						if (value) vnode.dom.setAttribute(key, "");
						else vnode.dom.removeAttribute(key);
					}
					else vnode.dom.setAttribute(key === "className" ? "class" : key, value);
				}
			}
			function removeAttr(vnode, key, old, ns) {
				if (key === "key" || key === "is" || old == null || isLifecycleMethod(key)) return
				if (key[0] === "o" && key[1] === "n") updateEvent(vnode, key, undefined);
				else if (key === "style") updateStyle(vnode.dom, old, null);
				else if (
					hasPropertyKey(vnode, key, ns)
					&& key !== "className"
					&& key !== "title" // creates "null" as title
					&& !(key === "value" && (
						vnode.tag === "option"
						|| vnode.tag === "select" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement()
					))
					&& !(vnode.tag === "input" && key === "type")
				) {
					vnode.dom[key] = null;
				} else {
					var nsLastIndex = key.indexOf(":");
					if (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1);
					if (old !== false) vnode.dom.removeAttribute(key === "className" ? "class" : key);
				}
			}
			function setLateSelectAttrs(vnode, attrs) {
				if ("value" in attrs) {
					if(attrs.value === null) {
						if (vnode.dom.selectedIndex !== -1) vnode.dom.value = null;
					} else {
						var normalized = "" + attrs.value; // eslint-disable-line no-implicit-coercion
						if (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {
							vnode.dom.value = normalized;
						}
					}
				}
				if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined);
			}
			function updateAttrs(vnode, old, attrs, ns) {
				if (old && old === attrs) {
					console.warn("Don't reuse attrs object, use new object for every redraw, this will throw in next major");
				}
				if (attrs != null) {
					// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
					//
					// Also, the DOM does things to inputs based on the value, so it needs set first.
					// See: https://github.com/MithrilJS/mithril.js/issues/2622
					if (vnode.tag === "input" && attrs.type != null) vnode.dom.setAttribute("type", attrs.type);
					var isFileInput = vnode.tag === "input" && attrs.type === "file";
					for (var key in attrs) {
						setAttr(vnode, key, old && old[key], attrs[key], ns, isFileInput);
					}
				}
				var val;
				if (old != null) {
					for (var key in old) {
						if (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {
							removeAttr(vnode, key, val, ns);
						}
					}
				}
			}
			function isFormAttribute(vnode, attr) {
				return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === activeElement() || vnode.tag === "option" && vnode.dom.parentNode === $doc.activeElement
			}
			function isLifecycleMethod(attr) {
				return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
			}
			function hasPropertyKey(vnode, key, ns) {
				// Filter out namespaced keys
				return ns === undefined && (
					// If it's a custom element, just keep it.
					vnode.tag.indexOf("-") > -1 || vnode.attrs != null && vnode.attrs.is ||
					// If it's a normal element, let's try to avoid a few browser bugs.
					key !== "href" && key !== "list" && key !== "form" && key !== "width" && key !== "height"// && key !== "type"
					// Defer the property check until *after* we check everything.
				) && key in vnode.dom
			}

			//style
			var uppercaseRegex = /[A-Z]/g;
			function toLowerCase(capital) { return "-" + capital.toLowerCase() }
			function normalizeKey(key) {
				return key[0] === "-" && key[1] === "-" ? key :
					key === "cssFloat" ? "float" :
						key.replace(uppercaseRegex, toLowerCase)
			}
			function updateStyle(element, old, style) {
				if (old === style) ; else if (style == null) {
					// New style is missing, just clear it.
					element.style.cssText = "";
				} else if (typeof style !== "object") {
					// New style is a string, let engine deal with patching.
					element.style.cssText = style;
				} else if (old == null || typeof old !== "object") {
					// `old` is missing or a string, `style` is an object.
					element.style.cssText = "";
					// Add new style properties
					for (var key in style) {
						var value = style[key];
						if (value != null) element.style.setProperty(normalizeKey(key), String(value));
					}
				} else {
					// Both old & new are (different) objects.
					// Update style properties that have changed
					for (var key in style) {
						var value = style[key];
						if (value != null && (value = String(value)) !== String(old[key])) {
							element.style.setProperty(normalizeKey(key), value);
						}
					}
					// Remove style properties that no longer exist
					for (var key in old) {
						if (old[key] != null && style[key] == null) {
							element.style.removeProperty(normalizeKey(key));
						}
					}
				}
			}

			// Here's an explanation of how this works:
			// 1. The event names are always (by design) prefixed by `on`.
			// 2. The EventListener interface accepts either a function or an object
			//    with a `handleEvent` method.
			// 3. The object does not inherit from `Object.prototype`, to avoid
			//    any potential interference with that (e.g. setters).
			// 4. The event name is remapped to the handler before calling it.
			// 5. In function-based event handlers, `ev.target === this`. We replicate
			//    that below.
			// 6. In function-based event handlers, `return false` prevents the default
			//    action and stops event propagation. We replicate that below.
			function EventDict() {
				// Save this, so the current redraw is correctly tracked.
				this._ = currentRedraw;
			}
			EventDict.prototype = Object.create(null);
			EventDict.prototype.handleEvent = function (ev) {
				var handler = this["on" + ev.type];
				var result;
				if (typeof handler === "function") result = handler.call(ev.currentTarget, ev);
				else if (typeof handler.handleEvent === "function") handler.handleEvent(ev);
				if (this._ && ev.redraw !== false) (0, this._)();
				if (result === false) {
					ev.preventDefault();
					ev.stopPropagation();
				}
			};

			//event
			function updateEvent(vnode, key, value) {
				if (vnode.events != null) {
					vnode.events._ = currentRedraw;
					if (vnode.events[key] === value) return
					if (value != null && (typeof value === "function" || typeof value === "object")) {
						if (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false);
						vnode.events[key] = value;
					} else {
						if (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false);
						vnode.events[key] = undefined;
					}
				} else if (value != null && (typeof value === "function" || typeof value === "object")) {
					vnode.events = new EventDict();
					vnode.dom.addEventListener(key.slice(2), vnode.events, false);
					vnode.events[key] = value;
				}
			}

			//lifecycle
			function initLifecycle(source, vnode, hooks) {
				if (typeof source.oninit === "function") callHook.call(source.oninit, vnode);
				if (typeof source.oncreate === "function") hooks.push(callHook.bind(source.oncreate, vnode));
			}
			function updateLifecycle(source, vnode, hooks) {
				if (typeof source.onupdate === "function") hooks.push(callHook.bind(source.onupdate, vnode));
			}
			function shouldNotUpdate(vnode, old) {
				do {
					if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") {
						var force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old);
						if (force !== undefined && !force) break
					}
					if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeupdate === "function") {
						var force = callHook.call(vnode.state.onbeforeupdate, vnode, old);
						if (force !== undefined && !force) break
					}
					return false
				} while (false); // eslint-disable-line no-constant-condition
				vnode.dom = old.dom;
				vnode.domSize = old.domSize;
				vnode.instance = old.instance;
				// One would think having the actual latest attributes would be ideal,
				// but it doesn't let us properly diff based on our current internal
				// representation. We have to save not only the old DOM info, but also
				// the attributes used to create it, as we diff *that*, not against the
				// DOM directly (with a few exceptions in `setAttr`). And, of course, we
				// need to save the children and text as they are conceptually not
				// unlike special "attributes" internally.
				vnode.attrs = old.attrs;
				vnode.children = old.children;
				vnode.text = old.text;
				return true
			}

			var currentDOM;

			return function(dom, vnodes, redraw) {
				if (!dom) throw new TypeError("DOM element being rendered to does not exist.")
				if (currentDOM != null && dom.contains(currentDOM)) {
					throw new TypeError("Node is currently being rendered to and thus is locked.")
				}
				var prevRedraw = currentRedraw;
				var prevDOM = currentDOM;
				var hooks = [];
				var active = activeElement();
				var namespace = dom.namespaceURI;

				currentDOM = dom;
				currentRedraw = typeof redraw === "function" ? redraw : undefined;
				try {
					// First time rendering into a node clears it out
					if (dom.vnodes == null) dom.textContent = "";
					vnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes]);
					updateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace);
					dom.vnodes = vnodes;
					// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement
					if (active != null && activeElement() !== active && typeof active.focus === "function") active.focus();
					for (var i = 0; i < hooks.length; i++) hooks[i]();
				} finally {
					currentRedraw = prevRedraw;
					currentDOM = prevDOM;
				}
			}
		};
		return render$2;
	}

	var render$1;
	var hasRequiredRender;

	function requireRender () {
		if (hasRequiredRender) return render$1;
		hasRequiredRender = 1;

		render$1 = requireRender$1()(typeof window !== "undefined" ? window : null);
		return render$1;
	}

	var Vnode = requireVnode();

	var mountRedraw$3 = function(render, schedule, console) {
		var subscriptions = [];
		var pending = false;
		var offset = -1;

		function sync() {
			for (offset = 0; offset < subscriptions.length; offset += 2) {
				try { render(subscriptions[offset], Vnode(subscriptions[offset + 1]), redraw); }
				catch (e) { console.error(e); }
			}
			offset = -1;
		}

		function redraw() {
			if (!pending) {
				pending = true;
				schedule(function() {
					pending = false;
					sync();
				});
			}
		}

		redraw.sync = sync;

		function mount(root, component) {
			if (component != null && component.view == null && typeof component !== "function") {
				throw new TypeError("m.mount expects a component, not a vnode.")
			}

			var index = subscriptions.indexOf(root);
			if (index >= 0) {
				subscriptions.splice(index, 2);
				if (index <= offset) offset -= 2;
				render(root, []);
			}

			if (component != null) {
				subscriptions.push(root, component);
				render(root, Vnode(component), redraw);
			}
		}

		return {mount: mount, redraw: redraw}
	};

	var render = requireRender();

	var mountRedraw$2 = mountRedraw$3(render, typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : null, typeof console !== "undefined" ? console : null);

	var build$1;
	var hasRequiredBuild$1;

	function requireBuild$1 () {
		if (hasRequiredBuild$1) return build$1;
		hasRequiredBuild$1 = 1;

		build$1 = function(object) {
			if (Object.prototype.toString.call(object) !== "[object Object]") return ""

			var args = [];
			for (var key in object) {
				destructure(key, object[key]);
			}

			return args.join("&")

			function destructure(key, value) {
				if (Array.isArray(value)) {
					for (var i = 0; i < value.length; i++) {
						destructure(key + "[" + i + "]", value[i]);
					}
				}
				else if (Object.prototype.toString.call(value) === "[object Object]") {
					for (var i in value) {
						destructure(key + "[" + i + "]", value[i]);
					}
				}
				else args.push(encodeURIComponent(key) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
			}
		};
		return build$1;
	}

	var assign;
	var hasRequiredAssign;

	function requireAssign () {
		if (hasRequiredAssign) return assign;
		hasRequiredAssign = 1;

		var hasOwn = requireHasOwn();

		assign = Object.assign || function(target, source) {
			for (var key in source) {
				if (hasOwn.call(source, key)) target[key] = source[key];
			}
		};
		return assign;
	}

	var build;
	var hasRequiredBuild;

	function requireBuild () {
		if (hasRequiredBuild) return build;
		hasRequiredBuild = 1;

		var buildQueryString = requireBuild$1();
		var assign = requireAssign();

		// Returns `path` from `template` + `params`
		build = function(template, params) {
			if ((/:([^\/\.-]+)(\.{3})?:/).test(template)) {
				throw new SyntaxError("Template parameter names must be separated by either a '/', '-', or '.'.")
			}
			if (params == null) return template
			var queryIndex = template.indexOf("?");
			var hashIndex = template.indexOf("#");
			var queryEnd = hashIndex < 0 ? template.length : hashIndex;
			var pathEnd = queryIndex < 0 ? queryEnd : queryIndex;
			var path = template.slice(0, pathEnd);
			var query = {};

			assign(query, params);

			var resolved = path.replace(/:([^\/\.-]+)(\.{3})?/g, function(m, key, variadic) {
				delete query[key];
				// If no such parameter exists, don't interpolate it.
				if (params[key] == null) return m
				// Escape normal parameters, but not variadic ones.
				return variadic ? params[key] : encodeURIComponent(String(params[key]))
			});

			// In case the template substitution adds new query/hash parameters.
			var newQueryIndex = resolved.indexOf("?");
			var newHashIndex = resolved.indexOf("#");
			var newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex;
			var newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex;
			var result = resolved.slice(0, newPathEnd);

			if (queryIndex >= 0) result += template.slice(queryIndex, queryEnd);
			if (newQueryIndex >= 0) result += (queryIndex < 0 ? "?" : "&") + resolved.slice(newQueryIndex, newQueryEnd);
			var querystring = buildQueryString(query);
			if (querystring) result += (queryIndex < 0 && newQueryIndex < 0 ? "?" : "&") + querystring;
			if (hashIndex >= 0) result += template.slice(hashIndex);
			if (newHashIndex >= 0) result += (hashIndex < 0 ? "" : "&") + resolved.slice(newHashIndex);
			return result
		};
		return build;
	}

	var buildPathname = requireBuild();
	var hasOwn = requireHasOwn();

	var request$2 = function($window, Promise, oncompletion) {
		var callbackCount = 0;

		function PromiseProxy(executor) {
			return new Promise(executor)
		}

		// In case the global Promise is some userland library's where they rely on
		// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or
		// similar. Let's *not* break them.
		PromiseProxy.prototype = Promise.prototype;
		PromiseProxy.__proto__ = Promise; // eslint-disable-line no-proto

		function makeRequest(factory) {
			return function(url, args) {
				if (typeof url !== "string") { args = url; url = url.url; }
				else if (args == null) args = {};
				var promise = new Promise(function(resolve, reject) {
					factory(buildPathname(url, args.params), args, function (data) {
						if (typeof args.type === "function") {
							if (Array.isArray(data)) {
								for (var i = 0; i < data.length; i++) {
									data[i] = new args.type(data[i]);
								}
							}
							else data = new args.type(data);
						}
						resolve(data);
					}, reject);
				});
				if (args.background === true) return promise
				var count = 0;
				function complete() {
					if (--count === 0 && typeof oncompletion === "function") oncompletion();
				}

				return wrap(promise)

				function wrap(promise) {
					var then = promise.then;
					// Set the constructor, so engines know to not await or resolve
					// this as a native promise. At the time of writing, this is
					// only necessary for V8, but their behavior is the correct
					// behavior per spec. See this spec issue for more details:
					// https://github.com/tc39/ecma262/issues/1577. Also, see the
					// corresponding comment in `request/tests/test-request.js` for
					// a bit more background on the issue at hand.
					promise.constructor = PromiseProxy;
					promise.then = function() {
						count++;
						var next = then.apply(promise, arguments);
						next.then(complete, function(e) {
							complete();
							if (count === 0) throw e
						});
						return wrap(next)
					};
					return promise
				}
			}
		}

		function hasHeader(args, name) {
			for (var key in args.headers) {
				if (hasOwn.call(args.headers, key) && key.toLowerCase() === name) return true
			}
			return false
		}

		return {
			request: makeRequest(function(url, args, resolve, reject) {
				var method = args.method != null ? args.method.toUpperCase() : "GET";
				var body = args.body;
				var assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData || body instanceof $window.URLSearchParams);
				var responseType = args.responseType || (typeof args.extract === "function" ? "" : "json");

				var xhr = new $window.XMLHttpRequest(), aborted = false, isTimeout = false;
				var original = xhr, replacedAbort;
				var abort = xhr.abort;

				xhr.abort = function() {
					aborted = true;
					abort.call(this);
				};

				xhr.open(method, url, args.async !== false, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);

				if (assumeJSON && body != null && !hasHeader(args, "content-type")) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (typeof args.deserialize !== "function" && !hasHeader(args, "accept")) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials;
				if (args.timeout) xhr.timeout = args.timeout;
				xhr.responseType = responseType;

				for (var key in args.headers) {
					if (hasOwn.call(args.headers, key)) {
						xhr.setRequestHeader(key, args.headers[key]);
					}
				}

				xhr.onreadystatechange = function(ev) {
					// Don't throw errors on xhr.abort().
					if (aborted) return

					if (ev.target.readyState === 4) {
						try {
							var success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\/\//i).test(url);
							// When the response type isn't "" or "text",
							// `xhr.responseText` is the wrong thing to use.
							// Browsers do the right thing and throw here, and we
							// should honor that and do the right thing by
							// preferring `xhr.response` where possible/practical.
							var response = ev.target.response, message;

							if (responseType === "json") {
								// For IE and Edge, which don't implement
								// `responseType: "json"`.
								if (!ev.target.responseType && typeof args.extract !== "function") {
									// Handle no-content which will not parse.
									try { response = JSON.parse(ev.target.responseText); }
									catch (e) { response = null; }
								}
							} else if (!responseType || responseType === "text") {
								// Only use this default if it's text. If a parsed
								// document is needed on old IE and friends (all
								// unsupported), the user should use a custom
								// `config` instead. They're already using this at
								// their own risk.
								if (response == null) response = ev.target.responseText;
							}

							if (typeof args.extract === "function") {
								response = args.extract(ev.target, args);
								success = true;
							} else if (typeof args.deserialize === "function") {
								response = args.deserialize(response);
							}
							if (success) resolve(response);
							else {
								var completeErrorResponse = function() {
									try { message = ev.target.responseText; }
									catch (e) { message = response; }
									var error = new Error(message);
									error.code = ev.target.status;
									error.response = response;
									reject(error);
								};

								if (xhr.status === 0) {
									// Use setTimeout to push this code block onto the event queue
									// This allows `xhr.ontimeout` to run in the case that there is a timeout
									// Without this setTimeout, `xhr.ontimeout` doesn't have a chance to reject
									// as `xhr.onreadystatechange` will run before it
									setTimeout(function() {
										if (isTimeout) return
										completeErrorResponse();
									});
								} else completeErrorResponse();
							}
						}
						catch (e) {
							reject(e);
						}
					}
				};

				xhr.ontimeout = function (ev) {
					isTimeout = true;
					var error = new Error("Request timed out");
					error.code = ev.target.status;
					reject(error);
				};

				if (typeof args.config === "function") {
					xhr = args.config(xhr, args, url) || xhr;

					// Propagate the `abort` to any replacement XHR as well.
					if (xhr !== original) {
						replacedAbort = xhr.abort;
						xhr.abort = function() {
							aborted = true;
							replacedAbort.call(this);
						};
					}
				}

				if (body == null) xhr.send();
				else if (typeof args.serialize === "function") xhr.send(args.serialize(body));
				else if (body instanceof $window.FormData || body instanceof $window.URLSearchParams) xhr.send(body);
				else xhr.send(JSON.stringify(body));
			}),
			jsonp: makeRequest(function(url, args, resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function(data) {
					delete $window[callbackName];
					script.parentNode.removeChild(script);
					resolve(data);
				};
				script.onerror = function() {
					delete $window[callbackName];
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
				};
				script.src = url + (url.indexOf("?") < 0 ? "?" : "&") +
					encodeURIComponent(args.callbackKey || "callback") + "=" +
					encodeURIComponent(callbackName);
				$window.document.documentElement.appendChild(script);
			}),
		}
	};

	var PromisePolyfill = promiseExports;
	var mountRedraw$1 = mountRedraw$2;

	var request$1 = request$2(typeof window !== "undefined" ? window : null, PromisePolyfill, mountRedraw$1.redraw);

	var parse$1;
	var hasRequiredParse$1;

	function requireParse$1 () {
		if (hasRequiredParse$1) return parse$1;
		hasRequiredParse$1 = 1;

		function decodeURIComponentSave(str) {
			try {
				return decodeURIComponent(str)
			} catch(err) {
				return str
			}
		}

		parse$1 = function(string) {
			if (string === "" || string == null) return {}
			if (string.charAt(0) === "?") string = string.slice(1);

			var entries = string.split("&"), counters = {}, data = {};
			for (var i = 0; i < entries.length; i++) {
				var entry = entries[i].split("=");
				var key = decodeURIComponentSave(entry[0]);
				var value = entry.length === 2 ? decodeURIComponentSave(entry[1]) : "";

				if (value === "true") value = true;
				else if (value === "false") value = false;

				var levels = key.split(/\]\[?|\[/);
				var cursor = data;
				if (key.indexOf("[") > -1) levels.pop();
				for (var j = 0; j < levels.length; j++) {
					var level = levels[j], nextLevel = levels[j + 1];
					var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
					if (level === "") {
						var key = levels.slice(0, j).join();
						if (counters[key] == null) {
							counters[key] = Array.isArray(cursor) ? cursor.length : 0;
						}
						level = counters[key]++;
					}
					// Disallow direct prototype pollution
					else if (level === "__proto__") break
					if (j === levels.length - 1) cursor[level] = value;
					else {
						// Read own properties exclusively to disallow indirect
						// prototype pollution
						var desc = Object.getOwnPropertyDescriptor(cursor, level);
						if (desc != null) desc = desc.value;
						if (desc == null) cursor[level] = desc = isNumber ? [] : {};
						cursor = desc;
					}
				}
			}
			return data
		};
		return parse$1;
	}

	var parse;
	var hasRequiredParse;

	function requireParse () {
		if (hasRequiredParse) return parse;
		hasRequiredParse = 1;

		var parseQueryString = requireParse$1();

		// Returns `{path, params}` from `url`
		parse = function(url) {
			var queryIndex = url.indexOf("?");
			var hashIndex = url.indexOf("#");
			var queryEnd = hashIndex < 0 ? url.length : hashIndex;
			var pathEnd = queryIndex < 0 ? queryEnd : queryIndex;
			var path = url.slice(0, pathEnd).replace(/\/{2,}/g, "/");

			if (!path) path = "/";
			else {
				if (path[0] !== "/") path = "/" + path;
				if (path.length > 1 && path[path.length - 1] === "/") path = path.slice(0, -1);
			}
			return {
				path: path,
				params: queryIndex < 0
					? {}
					: parseQueryString(url.slice(queryIndex + 1, queryEnd)),
			}
		};
		return parse;
	}

	var compileTemplate;
	var hasRequiredCompileTemplate;

	function requireCompileTemplate () {
		if (hasRequiredCompileTemplate) return compileTemplate;
		hasRequiredCompileTemplate = 1;

		var parsePathname = requireParse();

		// Compiles a template into a function that takes a resolved path (without query
		// strings) and returns an object containing the template parameters with their
		// parsed values. This expects the input of the compiled template to be the
		// output of `parsePathname`. Note that it does *not* remove query parameters
		// specified in the template.
		compileTemplate = function(template) {
			var templateData = parsePathname(template);
			var templateKeys = Object.keys(templateData.params);
			var keys = [];
			var regexp = new RegExp("^" + templateData.path.replace(
				// I escape literal text so people can use things like `:file.:ext` or
				// `:lang-:locale` in routes. This is all merged into one pass so I
				// don't also accidentally escape `-` and make it harder to detect it to
				// ban it from template parameters.
				/:([^\/.-]+)(\.{3}|\.(?!\.)|-)?|[\\^$*+.()|\[\]{}]/g,
				function(m, key, extra) {
					if (key == null) return "\\" + m
					keys.push({k: key, r: extra === "..."});
					if (extra === "...") return "(.*)"
					if (extra === ".") return "([^/]+)\\."
					return "([^/]+)" + (extra || "")
				}
			) + "$");
			return function(data) {
				// First, check the params. Usually, there isn't any, and it's just
				// checking a static set.
				for (var i = 0; i < templateKeys.length; i++) {
					if (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]]) return false
				}
				// If no interpolations exist, let's skip all the ceremony
				if (!keys.length) return regexp.test(data.path)
				var values = regexp.exec(data.path);
				if (values == null) return false
				for (var i = 0; i < keys.length; i++) {
					data.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1]);
				}
				return true
			}
		};
		return compileTemplate;
	}

	var censor;
	var hasRequiredCensor;

	function requireCensor () {
		if (hasRequiredCensor) return censor;
		hasRequiredCensor = 1;

		// Note: this is mildly perf-sensitive.
		//
		// It does *not* use `delete` - dynamic `delete`s usually cause objects to bail
		// out into dictionary mode and just generally cause a bunch of optimization
		// issues within engines.
		//
		// Ideally, I would've preferred to do this, if it weren't for the optimization
		// issues:
		//
		// ```js
		// const hasOwn = require("./hasOwn")
		// const magic = [
		//     "key", "oninit", "oncreate", "onbeforeupdate", "onupdate",
		//     "onbeforeremove", "onremove",
		// ]
		// module.exports = (attrs, extras) => {
		//     const result = Object.assign(Object.create(null), attrs)
		//     for (const key of magic) delete result[key]
		//     if (extras != null) for (const key of extras) delete result[key]
		//     return result
		// }
		// ```

		var hasOwn = requireHasOwn();
		// Words in RegExp literals are sometimes mangled incorrectly by the internal bundler, so use RegExp().
		var magic = new RegExp("^(?:key|oninit|oncreate|onbeforeupdate|onupdate|onbeforeremove|onremove)$");

		censor = function(attrs, extras) {
			var result = {};

			if (extras != null) {
				for (var key in attrs) {
					if (hasOwn.call(attrs, key) && !magic.test(key) && extras.indexOf(key) < 0) {
						result[key] = attrs[key];
					}
				}
			} else {
				for (var key in attrs) {
					if (hasOwn.call(attrs, key) && !magic.test(key)) {
						result[key] = attrs[key];
					}
				}
			}

			return result
		};
		return censor;
	}

	var router;
	var hasRequiredRouter;

	function requireRouter () {
		if (hasRequiredRouter) return router;
		hasRequiredRouter = 1;

		var Vnode = requireVnode();
		var m = hyperscript_1$1;
		var Promise = promiseExports;

		var buildPathname = requireBuild();
		var parsePathname = requireParse();
		var compileTemplate = requireCompileTemplate();
		var assign = requireAssign();
		var censor = requireCensor();

		var sentinel = {};

		function decodeURIComponentSave(component) {
			try {
				return decodeURIComponent(component)
			} catch(e) {
				return component
			}
		}

		router = function($window, mountRedraw) {
			var callAsync = $window == null
				// In case Mithril.js' loaded globally without the DOM, let's not break
				? null
				: typeof $window.setImmediate === "function" ? $window.setImmediate : $window.setTimeout;
			var p = Promise.resolve();

			var scheduled = false;

			// state === 0: init
			// state === 1: scheduled
			// state === 2: done
			var ready = false;
			var state = 0;

			var compiled, fallbackRoute;

			var currentResolver = sentinel, component, attrs, currentPath, lastUpdate;

			var RouterRoot = {
				onbeforeupdate: function() {
					state = state ? 2 : 1;
					return !(!state || sentinel === currentResolver)
				},
				onremove: function() {
					$window.removeEventListener("popstate", fireAsync, false);
					$window.removeEventListener("hashchange", resolveRoute, false);
				},
				view: function() {
					if (!state || sentinel === currentResolver) return
					// Wrap in a fragment to preserve existing key semantics
					var vnode = [Vnode(component, attrs.key, attrs)];
					if (currentResolver) vnode = currentResolver.render(vnode[0]);
					return vnode
				},
			};

			var SKIP = route.SKIP = {};

			function resolveRoute() {
				scheduled = false;
				// Consider the pathname holistically. The prefix might even be invalid,
				// but that's not our problem.
				var prefix = $window.location.hash;
				if (route.prefix[0] !== "#") {
					prefix = $window.location.search + prefix;
					if (route.prefix[0] !== "?") {
						prefix = $window.location.pathname + prefix;
						if (prefix[0] !== "/") prefix = "/" + prefix;
					}
				}
				// This seemingly useless `.concat()` speeds up the tests quite a bit,
				// since the representation is consistently a relatively poorly
				// optimized cons string.
				var path = prefix.concat()
					.replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponentSave)
					.slice(route.prefix.length);
				var data = parsePathname(path);

				assign(data.params, $window.history.state);

				function reject(e) {
					console.error(e);
					setPath(fallbackRoute, null, {replace: true});
				}

				loop(0);
				function loop(i) {
					// state === 0: init
					// state === 1: scheduled
					// state === 2: done
					for (; i < compiled.length; i++) {
						if (compiled[i].check(data)) {
							var payload = compiled[i].component;
							var matchedRoute = compiled[i].route;
							var localComp = payload;
							var update = lastUpdate = function(comp) {
								if (update !== lastUpdate) return
								if (comp === SKIP) return loop(i + 1)
								component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div";
								attrs = data.params, currentPath = path, lastUpdate = null;
								currentResolver = payload.render ? payload : null;
								if (state === 2) mountRedraw.redraw();
								else {
									state = 2;
									mountRedraw.redraw.sync();
								}
							};
							// There's no understating how much I *wish* I could
							// use `async`/`await` here...
							if (payload.view || typeof payload === "function") {
								payload = {};
								update(localComp);
							}
							else if (payload.onmatch) {
								p.then(function () {
									return payload.onmatch(data.params, path, matchedRoute)
								}).then(update, path === fallbackRoute ? null : reject);
							}
							else update("div");
							return
						}
					}

					if (path === fallbackRoute) {
						throw new Error("Could not resolve default route " + fallbackRoute + ".")
					}
					setPath(fallbackRoute, null, {replace: true});
				}
			}

			// Set it unconditionally so `m.route.set` and `m.route.Link` both work,
			// even if neither `pushState` nor `hashchange` are supported. It's
			// cleared if `hashchange` is used, since that makes it automatically
			// async.
			function fireAsync() {
				if (!scheduled) {
					scheduled = true;
					// TODO: just do `mountRedraw.redraw()` here and elide the timer
					// dependency. Note that this will muck with tests a *lot*, so it's
					// not as easy of a change as it sounds.
					callAsync(resolveRoute);
				}
			}

			function setPath(path, data, options) {
				path = buildPathname(path, data);
				if (ready) {
					fireAsync();
					var state = options ? options.state : null;
					var title = options ? options.title : null;
					if (options && options.replace) $window.history.replaceState(state, title, route.prefix + path);
					else $window.history.pushState(state, title, route.prefix + path);
				}
				else {
					$window.location.href = route.prefix + path;
				}
			}

			function route(root, defaultRoute, routes) {
				if (!root) throw new TypeError("DOM element being rendered to does not exist.")

				compiled = Object.keys(routes).map(function(route) {
					if (route[0] !== "/") throw new SyntaxError("Routes must start with a '/'.")
					if ((/:([^\/\.-]+)(\.{3})?:/).test(route)) {
						throw new SyntaxError("Route parameter names must be separated with either '/', '.', or '-'.")
					}
					return {
						route: route,
						component: routes[route],
						check: compileTemplate(route),
					}
				});
				fallbackRoute = defaultRoute;
				if (defaultRoute != null) {
					var defaultData = parsePathname(defaultRoute);

					if (!compiled.some(function (i) { return i.check(defaultData) })) {
						throw new ReferenceError("Default route doesn't match any known routes.")
					}
				}

				if (typeof $window.history.pushState === "function") {
					$window.addEventListener("popstate", fireAsync, false);
				} else if (route.prefix[0] === "#") {
					$window.addEventListener("hashchange", resolveRoute, false);
				}

				ready = true;
				mountRedraw.mount(root, RouterRoot);
				resolveRoute();
			}
			route.set = function(path, data, options) {
				if (lastUpdate != null) {
					options = options || {};
					options.replace = true;
				}
				lastUpdate = null;
				setPath(path, data, options);
			};
			route.get = function() {return currentPath};
			route.prefix = "#!";
			route.Link = {
				view: function(vnode) {
					// Omit the used parameters from the rendered element - they are
					// internal. Also, censor the various lifecycle methods.
					//
					// We don't strip the other parameters because for convenience we
					// let them be specified in the selector as well.
					var child = m(
						vnode.attrs.selector || "a",
						censor(vnode.attrs, ["options", "params", "selector", "onclick"]),
						vnode.children
					);
					var options, onclick, href;

					// Let's provide a *right* way to disable a route link, rather than
					// letting people screw up accessibility on accident.
					//
					// The attribute is coerced so users don't get surprised over
					// `disabled: 0` resulting in a button that's somehow routable
					// despite being visibly disabled.
					if (child.attrs.disabled = Boolean(child.attrs.disabled)) {
						child.attrs.href = null;
						child.attrs["aria-disabled"] = "true";
						// If you *really* do want add `onclick` on a disabled link, use
						// an `oncreate` hook to add it.
					} else {
						options = vnode.attrs.options;
						onclick = vnode.attrs.onclick;
						// Easier to build it now to keep it isomorphic.
						href = buildPathname(child.attrs.href, vnode.attrs.params);
						child.attrs.href = route.prefix + href;
						child.attrs.onclick = function(e) {
							var result;
							if (typeof onclick === "function") {
								result = onclick.call(e.currentTarget, e);
							} else if (onclick == null || typeof onclick !== "object") ; else if (typeof onclick.handleEvent === "function") {
								onclick.handleEvent(e);
							}

							// Adapted from React Router's implementation:
							// https://github.com/ReactTraining/react-router/blob/520a0acd48ae1b066eb0b07d6d4d1790a1d02482/packages/react-router-dom/modules/Link.js
							//
							// Try to be flexible and intuitive in how we handle links.
							// Fun fact: links aren't as obvious to get right as you
							// would expect. There's a lot more valid ways to click a
							// link than this, and one might want to not simply click a
							// link, but right click or command-click it to copy the
							// link target, etc. Nope, this isn't just for blind people.
							if (
								// Skip if `onclick` prevented default
								result !== false && !e.defaultPrevented &&
								// Ignore everything but left clicks
								(e.button === 0 || e.which === 0 || e.which === 1) &&
								// Let the browser handle `target=_blank`, etc.
								(!e.currentTarget.target || e.currentTarget.target === "_self") &&
								// No modifier keys
								!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey
							) {
								e.preventDefault();
								e.redraw = false;
								route.set(href, null, options);
							}
						};
					}
					return child
				},
			};
			route.param = function(key) {
				return attrs && key != null ? attrs[key] : attrs
			};

			return route
		};
		return router;
	}

	var route;
	var hasRequiredRoute;

	function requireRoute () {
		if (hasRequiredRoute) return route;
		hasRequiredRoute = 1;

		var mountRedraw = mountRedraw$2;

		route = requireRouter()(typeof window !== "undefined" ? window : null, mountRedraw);
		return route;
	}

	var hyperscript = hyperscript_1;
	var request = request$1;
	var mountRedraw = mountRedraw$2;

	var m = function m() { return hyperscript.apply(this, arguments) };
	m.m = hyperscript;
	m.trust = hyperscript.trust;
	m.fragment = hyperscript.fragment;
	m.Fragment = "[";
	m.mount = mountRedraw.mount;
	m.route = requireRoute();
	m.render = requireRender();
	m.redraw = mountRedraw.redraw;
	m.request = request.request;
	m.jsonp = request.jsonp;
	m.parseQueryString = requireParse$1();
	m.buildQueryString = requireBuild$1();
	m.parsePathname = requireParse();
	m.buildPathname = requireBuild();
	m.vnode = requireVnode();
	m.PromisePolyfill = requirePolyfill();
	m.censor = requireCensor();

	var mithril = m;

	var m$1 = /*@__PURE__*/getDefaultExportFromCjs(mithril);

	/**
	 * SSR Window 4.0.2
	 * Better handling for window object in SSR environment
	 * https://github.com/nolimits4web/ssr-window
	 *
	 * Copyright 2021, Vladimir Kharlampidi
	 *
	 * Licensed under MIT
	 *
	 * Released on: December 13, 2021
	 */
	/* eslint-disable no-param-reassign */
	function isObject$1(obj) {
	  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
	}
	function extend$1(target, src) {
	  if (target === void 0) {
	    target = {};
	  }
	  if (src === void 0) {
	    src = {};
	  }
	  Object.keys(src).forEach(key => {
	    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
	      extend$1(target[key], src[key]);
	    }
	  });
	}
	const ssrDocument = {
	  body: {},
	  addEventListener() {},
	  removeEventListener() {},
	  activeElement: {
	    blur() {},
	    nodeName: ''
	  },
	  querySelector() {
	    return null;
	  },
	  querySelectorAll() {
	    return [];
	  },
	  getElementById() {
	    return null;
	  },
	  createEvent() {
	    return {
	      initEvent() {}
	    };
	  },
	  createElement() {
	    return {
	      children: [],
	      childNodes: [],
	      style: {},
	      setAttribute() {},
	      getElementsByTagName() {
	        return [];
	      }
	    };
	  },
	  createElementNS() {
	    return {};
	  },
	  importNode() {
	    return null;
	  },
	  location: {
	    hash: '',
	    host: '',
	    hostname: '',
	    href: '',
	    origin: '',
	    pathname: '',
	    protocol: '',
	    search: ''
	  }
	};
	function getDocument() {
	  const doc = typeof document !== 'undefined' ? document : {};
	  extend$1(doc, ssrDocument);
	  return doc;
	}
	const ssrWindow = {
	  document: ssrDocument,
	  navigator: {
	    userAgent: ''
	  },
	  location: {
	    hash: '',
	    host: '',
	    hostname: '',
	    href: '',
	    origin: '',
	    pathname: '',
	    protocol: '',
	    search: ''
	  },
	  history: {
	    replaceState() {},
	    pushState() {},
	    go() {},
	    back() {}
	  },
	  CustomEvent: function CustomEvent() {
	    return this;
	  },
	  addEventListener() {},
	  removeEventListener() {},
	  getComputedStyle() {
	    return {
	      getPropertyValue() {
	        return '';
	      }
	    };
	  },
	  Image() {},
	  Date() {},
	  screen: {},
	  setTimeout() {},
	  clearTimeout() {},
	  matchMedia() {
	    return {};
	  },
	  requestAnimationFrame(callback) {
	    if (typeof setTimeout === 'undefined') {
	      callback();
	      return null;
	    }
	    return setTimeout(callback, 0);
	  },
	  cancelAnimationFrame(id) {
	    if (typeof setTimeout === 'undefined') {
	      return;
	    }
	    clearTimeout(id);
	  }
	};
	function getWindow() {
	  const win = typeof window !== 'undefined' ? window : {};
	  extend$1(win, ssrWindow);
	  return win;
	}

	function deleteProps(obj) {
	  const object = obj;
	  Object.keys(object).forEach(key => {
	    try {
	      object[key] = null;
	    } catch (e) {
	      // no getter for object
	    }
	    try {
	      delete object[key];
	    } catch (e) {
	      // something got wrong
	    }
	  });
	}
	function nextTick(callback, delay) {
	  if (delay === void 0) {
	    delay = 0;
	  }
	  return setTimeout(callback, delay);
	}
	function now() {
	  return Date.now();
	}
	function getComputedStyle$1(el) {
	  const window = getWindow();
	  let style;
	  if (window.getComputedStyle) {
	    style = window.getComputedStyle(el, null);
	  }
	  if (!style && el.currentStyle) {
	    style = el.currentStyle;
	  }
	  if (!style) {
	    style = el.style;
	  }
	  return style;
	}
	function getTranslate(el, axis) {
	  if (axis === void 0) {
	    axis = 'x';
	  }
	  const window = getWindow();
	  let matrix;
	  let curTransform;
	  let transformMatrix;
	  const curStyle = getComputedStyle$1(el);
	  if (window.WebKitCSSMatrix) {
	    curTransform = curStyle.transform || curStyle.webkitTransform;
	    if (curTransform.split(',').length > 6) {
	      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
	    }
	    // Some old versions of Webkit choke when 'none' is passed; pass
	    // empty string instead in this case
	    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	  } else {
	    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	    matrix = transformMatrix.toString().split(',');
	  }
	  if (axis === 'x') {
	    // Latest Chrome and webkits Fix
	    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
	    // Crazy IE10 Matrix
	    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
	    // Normal Browsers
	    else curTransform = parseFloat(matrix[4]);
	  }
	  if (axis === 'y') {
	    // Latest Chrome and webkits Fix
	    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
	    // Crazy IE10 Matrix
	    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
	    // Normal Browsers
	    else curTransform = parseFloat(matrix[5]);
	  }
	  return curTransform || 0;
	}
	function isObject(o) {
	  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
	}
	function isNode(node) {
	  // eslint-disable-next-line
	  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
	    return node instanceof HTMLElement;
	  }
	  return node && (node.nodeType === 1 || node.nodeType === 11);
	}
	function extend() {
	  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
	  const noExtend = ['__proto__', 'constructor', 'prototype'];
	  for (let i = 1; i < arguments.length; i += 1) {
	    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
	    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
	      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
	      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	        const nextKey = keysArray[nextIndex];
	        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	        if (desc !== undefined && desc.enumerable) {
	          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
	            if (nextSource[nextKey].__swiper__) {
	              to[nextKey] = nextSource[nextKey];
	            } else {
	              extend(to[nextKey], nextSource[nextKey]);
	            }
	          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
	            to[nextKey] = {};
	            if (nextSource[nextKey].__swiper__) {
	              to[nextKey] = nextSource[nextKey];
	            } else {
	              extend(to[nextKey], nextSource[nextKey]);
	            }
	          } else {
	            to[nextKey] = nextSource[nextKey];
	          }
	        }
	      }
	    }
	  }
	  return to;
	}
	function setCSSProperty(el, varName, varValue) {
	  el.style.setProperty(varName, varValue);
	}
	function animateCSSModeScroll(_ref) {
	  let {
	    swiper,
	    targetPosition,
	    side
	  } = _ref;
	  const window = getWindow();
	  const startPosition = -swiper.translate;
	  let startTime = null;
	  let time;
	  const duration = swiper.params.speed;
	  swiper.wrapperEl.style.scrollSnapType = 'none';
	  window.cancelAnimationFrame(swiper.cssModeFrameID);
	  const dir = targetPosition > startPosition ? 'next' : 'prev';
	  const isOutOfBound = (current, target) => {
	    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
	  };
	  const animate = () => {
	    time = new Date().getTime();
	    if (startTime === null) {
	      startTime = time;
	    }
	    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
	    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
	    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
	    if (isOutOfBound(currentPosition, targetPosition)) {
	      currentPosition = targetPosition;
	    }
	    swiper.wrapperEl.scrollTo({
	      [side]: currentPosition
	    });
	    if (isOutOfBound(currentPosition, targetPosition)) {
	      swiper.wrapperEl.style.overflow = 'hidden';
	      swiper.wrapperEl.style.scrollSnapType = '';
	      setTimeout(() => {
	        swiper.wrapperEl.style.overflow = '';
	        swiper.wrapperEl.scrollTo({
	          [side]: currentPosition
	        });
	      });
	      window.cancelAnimationFrame(swiper.cssModeFrameID);
	      return;
	    }
	    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
	  };
	  animate();
	}
	function elementChildren(element, selector) {
	  if (selector === void 0) {
	    selector = '';
	  }
	  return [...element.children].filter(el => el.matches(selector));
	}
	function createElement(tag, classes) {
	  if (classes === void 0) {
	    classes = [];
	  }
	  const el = document.createElement(tag);
	  el.classList.add(...(Array.isArray(classes) ? classes : [classes]));
	  return el;
	}
	function elementOffset(el) {
	  const window = getWindow();
	  const document = getDocument();
	  const box = el.getBoundingClientRect();
	  const body = document.body;
	  const clientTop = el.clientTop || body.clientTop || 0;
	  const clientLeft = el.clientLeft || body.clientLeft || 0;
	  const scrollTop = el === window ? window.scrollY : el.scrollTop;
	  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
	  return {
	    top: box.top + scrollTop - clientTop,
	    left: box.left + scrollLeft - clientLeft
	  };
	}
	function elementPrevAll(el, selector) {
	  const prevEls = [];
	  while (el.previousElementSibling) {
	    const prev = el.previousElementSibling; // eslint-disable-line
	    if (selector) {
	      if (prev.matches(selector)) prevEls.push(prev);
	    } else prevEls.push(prev);
	    el = prev;
	  }
	  return prevEls;
	}
	function elementNextAll(el, selector) {
	  const nextEls = [];
	  while (el.nextElementSibling) {
	    const next = el.nextElementSibling; // eslint-disable-line
	    if (selector) {
	      if (next.matches(selector)) nextEls.push(next);
	    } else nextEls.push(next);
	    el = next;
	  }
	  return nextEls;
	}
	function elementStyle(el, prop) {
	  const window = getWindow();
	  return window.getComputedStyle(el, null).getPropertyValue(prop);
	}
	function elementIndex(el) {
	  let child = el;
	  let i;
	  if (child) {
	    i = 0;
	    // eslint-disable-next-line
	    while ((child = child.previousSibling) !== null) {
	      if (child.nodeType === 1) i += 1;
	    }
	    return i;
	  }
	  return undefined;
	}
	function elementParents(el, selector) {
	  const parents = []; // eslint-disable-line
	  let parent = el.parentElement; // eslint-disable-line
	  while (parent) {
	    if (selector) {
	      if (parent.matches(selector)) parents.push(parent);
	    } else {
	      parents.push(parent);
	    }
	    parent = parent.parentElement;
	  }
	  return parents;
	}
	function elementOuterSize(el, size, includeMargins) {
	  const window = getWindow();
	  if (includeMargins) {
	    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
	  }
	  return el.offsetWidth;
	}

	let support;
	function calcSupport() {
	  const window = getWindow();
	  const document = getDocument();
	  return {
	    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
	    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
	  };
	}
	function getSupport() {
	  if (!support) {
	    support = calcSupport();
	  }
	  return support;
	}

	let deviceCached;
	function calcDevice(_temp) {
	  let {
	    userAgent
	  } = _temp === void 0 ? {} : _temp;
	  const support = getSupport();
	  const window = getWindow();
	  const platform = window.navigator.platform;
	  const ua = userAgent || window.navigator.userAgent;
	  const device = {
	    ios: false,
	    android: false
	  };
	  const screenWidth = window.screen.width;
	  const screenHeight = window.screen.height;
	  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
	  const windows = platform === 'Win32';
	  let macos = platform === 'MacIntel';

	  // iPadOs 13 fix
	  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
	  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
	    ipad = ua.match(/(Version)\/([\d.]+)/);
	    if (!ipad) ipad = [0, 1, '13_0_0'];
	    macos = false;
	  }

	  // Android
	  if (android && !windows) {
	    device.os = 'android';
	    device.android = true;
	  }
	  if (ipad || iphone || ipod) {
	    device.os = 'ios';
	    device.ios = true;
	  }

	  // Export object
	  return device;
	}
	function getDevice(overrides) {
	  if (overrides === void 0) {
	    overrides = {};
	  }
	  if (!deviceCached) {
	    deviceCached = calcDevice(overrides);
	  }
	  return deviceCached;
	}

	let browser;
	function calcBrowser() {
	  const window = getWindow();
	  let needPerspectiveFix = false;
	  function isSafari() {
	    const ua = window.navigator.userAgent.toLowerCase();
	    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
	  }
	  if (isSafari()) {
	    const ua = String(window.navigator.userAgent);
	    if (ua.includes('Version/')) {
	      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
	      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
	    }
	  }
	  return {
	    isSafari: needPerspectiveFix || isSafari(),
	    needPerspectiveFix,
	    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
	  };
	}
	function getBrowser() {
	  if (!browser) {
	    browser = calcBrowser();
	  }
	  return browser;
	}

	function Resize(_ref) {
	  let {
	    swiper,
	    on,
	    emit
	  } = _ref;
	  const window = getWindow();
	  let observer = null;
	  let animationFrame = null;
	  const resizeHandler = () => {
	    if (!swiper || swiper.destroyed || !swiper.initialized) return;
	    emit('beforeResize');
	    emit('resize');
	  };
	  const createObserver = () => {
	    if (!swiper || swiper.destroyed || !swiper.initialized) return;
	    observer = new ResizeObserver(entries => {
	      animationFrame = window.requestAnimationFrame(() => {
	        const {
	          width,
	          height
	        } = swiper;
	        let newWidth = width;
	        let newHeight = height;
	        entries.forEach(_ref2 => {
	          let {
	            contentBoxSize,
	            contentRect,
	            target
	          } = _ref2;
	          if (target && target !== swiper.el) return;
	          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
	          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
	        });
	        if (newWidth !== width || newHeight !== height) {
	          resizeHandler();
	        }
	      });
	    });
	    observer.observe(swiper.el);
	  };
	  const removeObserver = () => {
	    if (animationFrame) {
	      window.cancelAnimationFrame(animationFrame);
	    }
	    if (observer && observer.unobserve && swiper.el) {
	      observer.unobserve(swiper.el);
	      observer = null;
	    }
	  };
	  const orientationChangeHandler = () => {
	    if (!swiper || swiper.destroyed || !swiper.initialized) return;
	    emit('orientationchange');
	  };
	  on('init', () => {
	    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
	      createObserver();
	      return;
	    }
	    window.addEventListener('resize', resizeHandler);
	    window.addEventListener('orientationchange', orientationChangeHandler);
	  });
	  on('destroy', () => {
	    removeObserver();
	    window.removeEventListener('resize', resizeHandler);
	    window.removeEventListener('orientationchange', orientationChangeHandler);
	  });
	}

	function Observer(_ref) {
	  let {
	    swiper,
	    extendParams,
	    on,
	    emit
	  } = _ref;
	  const observers = [];
	  const window = getWindow();
	  const attach = function (target, options) {
	    if (options === void 0) {
	      options = {};
	    }
	    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
	    const observer = new ObserverFunc(mutations => {
	      // The observerUpdate event should only be triggered
	      // once despite the number of mutations.  Additional
	      // triggers are redundant and are very costly
	      if (swiper.__preventObserver__) return;
	      if (mutations.length === 1) {
	        emit('observerUpdate', mutations[0]);
	        return;
	      }
	      const observerUpdate = function observerUpdate() {
	        emit('observerUpdate', mutations[0]);
	      };
	      if (window.requestAnimationFrame) {
	        window.requestAnimationFrame(observerUpdate);
	      } else {
	        window.setTimeout(observerUpdate, 0);
	      }
	    });
	    observer.observe(target, {
	      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	      childList: typeof options.childList === 'undefined' ? true : options.childList,
	      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
	    });
	    observers.push(observer);
	  };
	  const init = () => {
	    if (!swiper.params.observer) return;
	    if (swiper.params.observeParents) {
	      const containerParents = elementParents(swiper.hostEl);
	      for (let i = 0; i < containerParents.length; i += 1) {
	        attach(containerParents[i]);
	      }
	    }
	    // Observe container
	    attach(swiper.hostEl, {
	      childList: swiper.params.observeSlideChildren
	    });

	    // Observe wrapper
	    attach(swiper.wrapperEl, {
	      attributes: false
	    });
	  };
	  const destroy = () => {
	    observers.forEach(observer => {
	      observer.disconnect();
	    });
	    observers.splice(0, observers.length);
	  };
	  extendParams({
	    observer: false,
	    observeParents: false,
	    observeSlideChildren: false
	  });
	  on('init', init);
	  on('destroy', destroy);
	}

	/* eslint-disable no-underscore-dangle */

	var eventsEmitter = {
	  on(events, handler, priority) {
	    const self = this;
	    if (!self.eventsListeners || self.destroyed) return self;
	    if (typeof handler !== 'function') return self;
	    const method = priority ? 'unshift' : 'push';
	    events.split(' ').forEach(event => {
	      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
	      self.eventsListeners[event][method](handler);
	    });
	    return self;
	  },
	  once(events, handler, priority) {
	    const self = this;
	    if (!self.eventsListeners || self.destroyed) return self;
	    if (typeof handler !== 'function') return self;
	    function onceHandler() {
	      self.off(events, onceHandler);
	      if (onceHandler.__emitterProxy) {
	        delete onceHandler.__emitterProxy;
	      }
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      handler.apply(self, args);
	    }
	    onceHandler.__emitterProxy = handler;
	    return self.on(events, onceHandler, priority);
	  },
	  onAny(handler, priority) {
	    const self = this;
	    if (!self.eventsListeners || self.destroyed) return self;
	    if (typeof handler !== 'function') return self;
	    const method = priority ? 'unshift' : 'push';
	    if (self.eventsAnyListeners.indexOf(handler) < 0) {
	      self.eventsAnyListeners[method](handler);
	    }
	    return self;
	  },
	  offAny(handler) {
	    const self = this;
	    if (!self.eventsListeners || self.destroyed) return self;
	    if (!self.eventsAnyListeners) return self;
	    const index = self.eventsAnyListeners.indexOf(handler);
	    if (index >= 0) {
	      self.eventsAnyListeners.splice(index, 1);
	    }
	    return self;
	  },
	  off(events, handler) {
	    const self = this;
	    if (!self.eventsListeners || self.destroyed) return self;
	    if (!self.eventsListeners) return self;
	    events.split(' ').forEach(event => {
	      if (typeof handler === 'undefined') {
	        self.eventsListeners[event] = [];
	      } else if (self.eventsListeners[event]) {
	        self.eventsListeners[event].forEach((eventHandler, index) => {
	          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
	            self.eventsListeners[event].splice(index, 1);
	          }
	        });
	      }
	    });
	    return self;
	  },
	  emit() {
	    const self = this;
	    if (!self.eventsListeners || self.destroyed) return self;
	    if (!self.eventsListeners) return self;
	    let events;
	    let data;
	    let context;
	    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      args[_key2] = arguments[_key2];
	    }
	    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
	      events = args[0];
	      data = args.slice(1, args.length);
	      context = self;
	    } else {
	      events = args[0].events;
	      data = args[0].data;
	      context = args[0].context || self;
	    }
	    data.unshift(context);
	    const eventsArray = Array.isArray(events) ? events : events.split(' ');
	    eventsArray.forEach(event => {
	      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
	        self.eventsAnyListeners.forEach(eventHandler => {
	          eventHandler.apply(context, [event, ...data]);
	        });
	      }
	      if (self.eventsListeners && self.eventsListeners[event]) {
	        self.eventsListeners[event].forEach(eventHandler => {
	          eventHandler.apply(context, data);
	        });
	      }
	    });
	    return self;
	  }
	};

	function updateSize() {
	  const swiper = this;
	  let width;
	  let height;
	  const el = swiper.el;
	  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
	    width = swiper.params.width;
	  } else {
	    width = el.clientWidth;
	  }
	  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
	    height = swiper.params.height;
	  } else {
	    height = el.clientHeight;
	  }
	  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
	    return;
	  }

	  // Subtract paddings
	  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
	  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
	  if (Number.isNaN(width)) width = 0;
	  if (Number.isNaN(height)) height = 0;
	  Object.assign(swiper, {
	    width,
	    height,
	    size: swiper.isHorizontal() ? width : height
	  });
	}

	function updateSlides() {
	  const swiper = this;
	  function getDirectionLabel(property) {
	    if (swiper.isHorizontal()) {
	      return property;
	    }
	    // prettier-ignore
	    return {
	      'width': 'height',
	      'margin-top': 'margin-left',
	      'margin-bottom ': 'margin-right',
	      'margin-left': 'margin-top',
	      'margin-right': 'margin-bottom',
	      'padding-left': 'padding-top',
	      'padding-right': 'padding-bottom',
	      'marginRight': 'marginBottom'
	    }[property];
	  }
	  function getDirectionPropertyValue(node, label) {
	    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
	  }
	  const params = swiper.params;
	  const {
	    wrapperEl,
	    slidesEl,
	    size: swiperSize,
	    rtlTranslate: rtl,
	    wrongRTL
	  } = swiper;
	  const isVirtual = swiper.virtual && params.virtual.enabled;
	  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
	  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
	  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
	  let snapGrid = [];
	  const slidesGrid = [];
	  const slidesSizesGrid = [];
	  let offsetBefore = params.slidesOffsetBefore;
	  if (typeof offsetBefore === 'function') {
	    offsetBefore = params.slidesOffsetBefore.call(swiper);
	  }
	  let offsetAfter = params.slidesOffsetAfter;
	  if (typeof offsetAfter === 'function') {
	    offsetAfter = params.slidesOffsetAfter.call(swiper);
	  }
	  const previousSnapGridLength = swiper.snapGrid.length;
	  const previousSlidesGridLength = swiper.slidesGrid.length;
	  let spaceBetween = params.spaceBetween;
	  let slidePosition = -offsetBefore;
	  let prevSlideSize = 0;
	  let index = 0;
	  if (typeof swiperSize === 'undefined') {
	    return;
	  }
	  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
	  } else if (typeof spaceBetween === 'string') {
	    spaceBetween = parseFloat(spaceBetween);
	  }
	  swiper.virtualSize = -spaceBetween;

	  // reset margins
	  slides.forEach(slideEl => {
	    if (rtl) {
	      slideEl.style.marginLeft = '';
	    } else {
	      slideEl.style.marginRight = '';
	    }
	    slideEl.style.marginBottom = '';
	    slideEl.style.marginTop = '';
	  });

	  // reset cssMode offsets
	  if (params.centeredSlides && params.cssMode) {
	    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
	    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
	  }
	  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
	  if (gridEnabled) {
	    swiper.grid.initSlides(slidesLength);
	  }

	  // Calc slides
	  let slideSize;
	  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
	    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
	  }).length > 0;
	  for (let i = 0; i < slidesLength; i += 1) {
	    slideSize = 0;
	    let slide;
	    if (slides[i]) slide = slides[i];
	    if (gridEnabled) {
	      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
	    }
	    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

	    if (params.slidesPerView === 'auto') {
	      if (shouldResetSlideSize) {
	        slides[i].style[getDirectionLabel('width')] = ``;
	      }
	      const slideStyles = getComputedStyle(slide);
	      const currentTransform = slide.style.transform;
	      const currentWebKitTransform = slide.style.webkitTransform;
	      if (currentTransform) {
	        slide.style.transform = 'none';
	      }
	      if (currentWebKitTransform) {
	        slide.style.webkitTransform = 'none';
	      }
	      if (params.roundLengths) {
	        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);
	      } else {
	        // eslint-disable-next-line
	        const width = getDirectionPropertyValue(slideStyles, 'width');
	        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
	        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
	        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
	        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
	        const boxSizing = slideStyles.getPropertyValue('box-sizing');
	        if (boxSizing && boxSizing === 'border-box') {
	          slideSize = width + marginLeft + marginRight;
	        } else {
	          const {
	            clientWidth,
	            offsetWidth
	          } = slide;
	          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
	        }
	      }
	      if (currentTransform) {
	        slide.style.transform = currentTransform;
	      }
	      if (currentWebKitTransform) {
	        slide.style.webkitTransform = currentWebKitTransform;
	      }
	      if (params.roundLengths) slideSize = Math.floor(slideSize);
	    } else {
	      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
	      if (params.roundLengths) slideSize = Math.floor(slideSize);
	      if (slides[i]) {
	        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
	      }
	    }
	    if (slides[i]) {
	      slides[i].swiperSlideSize = slideSize;
	    }
	    slidesSizesGrid.push(slideSize);
	    if (params.centeredSlides) {
	      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
	      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
	      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
	      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
	      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
	      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
	      slidesGrid.push(slidePosition);
	    } else {
	      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
	      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
	      slidesGrid.push(slidePosition);
	      slidePosition = slidePosition + slideSize + spaceBetween;
	    }
	    swiper.virtualSize += slideSize + spaceBetween;
	    prevSlideSize = slideSize;
	    index += 1;
	  }
	  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
	  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
	    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
	  }
	  if (params.setWrapperSize) {
	    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
	  }
	  if (gridEnabled) {
	    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
	  }

	  // Remove last grid elements depending on width
	  if (!params.centeredSlides) {
	    const newSlidesGrid = [];
	    for (let i = 0; i < snapGrid.length; i += 1) {
	      let slidesGridItem = snapGrid[i];
	      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
	      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
	        newSlidesGrid.push(slidesGridItem);
	      }
	    }
	    snapGrid = newSlidesGrid;
	    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
	      snapGrid.push(swiper.virtualSize - swiperSize);
	    }
	  }
	  if (isVirtual && params.loop) {
	    const size = slidesSizesGrid[0] + spaceBetween;
	    if (params.slidesPerGroup > 1) {
	      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
	      const groupSize = size * params.slidesPerGroup;
	      for (let i = 0; i < groups; i += 1) {
	        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
	      }
	    }
	    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
	      if (params.slidesPerGroup === 1) {
	        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
	      }
	      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
	      swiper.virtualSize += size;
	    }
	  }
	  if (snapGrid.length === 0) snapGrid = [0];
	  if (spaceBetween !== 0) {
	    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
	    slides.filter((_, slideIndex) => {
	      if (!params.cssMode || params.loop) return true;
	      if (slideIndex === slides.length - 1) {
	        return false;
	      }
	      return true;
	    }).forEach(slideEl => {
	      slideEl.style[key] = `${spaceBetween}px`;
	    });
	  }
	  if (params.centeredSlides && params.centeredSlidesBounds) {
	    let allSlidesSize = 0;
	    slidesSizesGrid.forEach(slideSizeValue => {
	      allSlidesSize += slideSizeValue + (spaceBetween || 0);
	    });
	    allSlidesSize -= spaceBetween;
	    const maxSnap = allSlidesSize - swiperSize;
	    snapGrid = snapGrid.map(snap => {
	      if (snap <= 0) return -offsetBefore;
	      if (snap > maxSnap) return maxSnap + offsetAfter;
	      return snap;
	    });
	  }
	  if (params.centerInsufficientSlides) {
	    let allSlidesSize = 0;
	    slidesSizesGrid.forEach(slideSizeValue => {
	      allSlidesSize += slideSizeValue + (spaceBetween || 0);
	    });
	    allSlidesSize -= spaceBetween;
	    if (allSlidesSize < swiperSize) {
	      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
	      snapGrid.forEach((snap, snapIndex) => {
	        snapGrid[snapIndex] = snap - allSlidesOffset;
	      });
	      slidesGrid.forEach((snap, snapIndex) => {
	        slidesGrid[snapIndex] = snap + allSlidesOffset;
	      });
	    }
	  }
	  Object.assign(swiper, {
	    slides,
	    snapGrid,
	    slidesGrid,
	    slidesSizesGrid
	  });
	  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
	    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
	    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
	    const addToSnapGrid = -swiper.snapGrid[0];
	    const addToSlidesGrid = -swiper.slidesGrid[0];
	    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
	    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
	  }
	  if (slidesLength !== previousSlidesLength) {
	    swiper.emit('slidesLengthChange');
	  }
	  if (snapGrid.length !== previousSnapGridLength) {
	    if (swiper.params.watchOverflow) swiper.checkOverflow();
	    swiper.emit('snapGridLengthChange');
	  }
	  if (slidesGrid.length !== previousSlidesGridLength) {
	    swiper.emit('slidesGridLengthChange');
	  }
	  if (params.watchSlidesProgress) {
	    swiper.updateSlidesOffset();
	  }
	  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
	    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
	    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
	    if (slidesLength <= params.maxBackfaceHiddenSlides) {
	      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
	    } else if (hasClassBackfaceClassAdded) {
	      swiper.el.classList.remove(backFaceHiddenClass);
	    }
	  }
	}

	function updateAutoHeight(speed) {
	  const swiper = this;
	  const activeSlides = [];
	  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	  let newHeight = 0;
	  let i;
	  if (typeof speed === 'number') {
	    swiper.setTransition(speed);
	  } else if (speed === true) {
	    swiper.setTransition(swiper.params.speed);
	  }
	  const getSlideByIndex = index => {
	    if (isVirtual) {
	      return swiper.slides[swiper.getSlideIndexByData(index)];
	    }
	    return swiper.slides[index];
	  };
	  // Find slides currently in view
	  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
	    if (swiper.params.centeredSlides) {
	      (swiper.visibleSlides || []).forEach(slide => {
	        activeSlides.push(slide);
	      });
	    } else {
	      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
	        const index = swiper.activeIndex + i;
	        if (index > swiper.slides.length && !isVirtual) break;
	        activeSlides.push(getSlideByIndex(index));
	      }
	    }
	  } else {
	    activeSlides.push(getSlideByIndex(swiper.activeIndex));
	  }

	  // Find new height from highest slide in view
	  for (i = 0; i < activeSlides.length; i += 1) {
	    if (typeof activeSlides[i] !== 'undefined') {
	      const height = activeSlides[i].offsetHeight;
	      newHeight = height > newHeight ? height : newHeight;
	    }
	  }

	  // Update Height
	  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
	}

	function updateSlidesOffset() {
	  const swiper = this;
	  const slides = swiper.slides;
	  // eslint-disable-next-line
	  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
	  for (let i = 0; i < slides.length; i += 1) {
	    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
	  }
	}

	function updateSlidesProgress(translate) {
	  if (translate === void 0) {
	    translate = this && this.translate || 0;
	  }
	  const swiper = this;
	  const params = swiper.params;
	  const {
	    slides,
	    rtlTranslate: rtl,
	    snapGrid
	  } = swiper;
	  if (slides.length === 0) return;
	  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
	  let offsetCenter = -translate;
	  if (rtl) offsetCenter = translate;

	  // Visible Slides
	  slides.forEach(slideEl => {
	    slideEl.classList.remove(params.slideVisibleClass);
	  });
	  swiper.visibleSlidesIndexes = [];
	  swiper.visibleSlides = [];
	  let spaceBetween = params.spaceBetween;
	  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
	  } else if (typeof spaceBetween === 'string') {
	    spaceBetween = parseFloat(spaceBetween);
	  }
	  for (let i = 0; i < slides.length; i += 1) {
	    const slide = slides[i];
	    let slideOffset = slide.swiperSlideOffset;
	    if (params.cssMode && params.centeredSlides) {
	      slideOffset -= slides[0].swiperSlideOffset;
	    }
	    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
	    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
	    const slideBefore = -(offsetCenter - slideOffset);
	    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
	    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
	    if (isVisible) {
	      swiper.visibleSlides.push(slide);
	      swiper.visibleSlidesIndexes.push(i);
	      slides[i].classList.add(params.slideVisibleClass);
	    }
	    slide.progress = rtl ? -slideProgress : slideProgress;
	    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
	  }
	}

	function updateProgress(translate) {
	  const swiper = this;
	  if (typeof translate === 'undefined') {
	    const multiplier = swiper.rtlTranslate ? -1 : 1;
	    // eslint-disable-next-line
	    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
	  }
	  const params = swiper.params;
	  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  let {
	    progress,
	    isBeginning,
	    isEnd,
	    progressLoop
	  } = swiper;
	  const wasBeginning = isBeginning;
	  const wasEnd = isEnd;
	  if (translatesDiff === 0) {
	    progress = 0;
	    isBeginning = true;
	    isEnd = true;
	  } else {
	    progress = (translate - swiper.minTranslate()) / translatesDiff;
	    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
	    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
	    isBeginning = isBeginningRounded || progress <= 0;
	    isEnd = isEndRounded || progress >= 1;
	    if (isBeginningRounded) progress = 0;
	    if (isEndRounded) progress = 1;
	  }
	  if (params.loop) {
	    const firstSlideIndex = swiper.getSlideIndexByData(0);
	    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
	    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
	    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
	    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
	    const translateAbs = Math.abs(translate);
	    if (translateAbs >= firstSlideTranslate) {
	      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
	    } else {
	      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
	    }
	    if (progressLoop > 1) progressLoop -= 1;
	  }
	  Object.assign(swiper, {
	    progress,
	    progressLoop,
	    isBeginning,
	    isEnd
	  });
	  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
	  if (isBeginning && !wasBeginning) {
	    swiper.emit('reachBeginning toEdge');
	  }
	  if (isEnd && !wasEnd) {
	    swiper.emit('reachEnd toEdge');
	  }
	  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
	    swiper.emit('fromEdge');
	  }
	  swiper.emit('progress', progress);
	}

	function updateSlidesClasses() {
	  const swiper = this;
	  const {
	    slides,
	    params,
	    slidesEl,
	    activeIndex
	  } = swiper;
	  const isVirtual = swiper.virtual && params.virtual.enabled;
	  const getFilteredSlide = selector => {
	    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
	  };
	  slides.forEach(slideEl => {
	    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
	  });
	  let activeSlide;
	  if (isVirtual) {
	    if (params.loop) {
	      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
	      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
	      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
	      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
	    } else {
	      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
	    }
	  } else {
	    activeSlide = slides[activeIndex];
	  }
	  if (activeSlide) {
	    // Active classes
	    activeSlide.classList.add(params.slideActiveClass);

	    // Next Slide
	    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
	    if (params.loop && !nextSlide) {
	      nextSlide = slides[0];
	    }
	    if (nextSlide) {
	      nextSlide.classList.add(params.slideNextClass);
	    }
	    // Prev Slide
	    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
	    if (params.loop && !prevSlide === 0) {
	      prevSlide = slides[slides.length - 1];
	    }
	    if (prevSlide) {
	      prevSlide.classList.add(params.slidePrevClass);
	    }
	  }
	  swiper.emitSlidesClasses();
	}

	const processLazyPreloader = (swiper, imageEl) => {
	  if (!swiper || swiper.destroyed || !swiper.params) return;
	  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
	  const slideEl = imageEl.closest(slideSelector());
	  if (slideEl) {
	    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
	    if (!lazyEl && swiper.isElement) {
	      if (slideEl.shadowRoot) {
	        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
	      } else {
	        // init later
	        requestAnimationFrame(() => {
	          if (slideEl.shadowRoot) {
	            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
	            if (lazyEl) lazyEl.remove();
	          }
	        });
	      }
	    }
	    if (lazyEl) lazyEl.remove();
	  }
	};
	const unlazy = (swiper, index) => {
	  if (!swiper.slides[index]) return;
	  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
	  if (imageEl) imageEl.removeAttribute('loading');
	};
	const preload = swiper => {
	  if (!swiper || swiper.destroyed || !swiper.params) return;
	  let amount = swiper.params.lazyPreloadPrevNext;
	  const len = swiper.slides.length;
	  if (!len || !amount || amount < 0) return;
	  amount = Math.min(amount, len);
	  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
	  const activeIndex = swiper.activeIndex;
	  if (swiper.params.grid && swiper.params.grid.rows > 1) {
	    const activeColumn = activeIndex;
	    const preloadColumns = [activeColumn - amount];
	    preloadColumns.push(...Array.from({
	      length: amount
	    }).map((_, i) => {
	      return activeColumn + slidesPerView + i;
	    }));
	    swiper.slides.forEach((slideEl, i) => {
	      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
	    });
	    return;
	  }
	  const slideIndexLastInView = activeIndex + slidesPerView - 1;
	  if (swiper.params.rewind || swiper.params.loop) {
	    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
	      const realIndex = (i % len + len) % len;
	      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
	    }
	  } else {
	    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
	      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
	        unlazy(swiper, i);
	      }
	    }
	  }
	};

	function getActiveIndexByTranslate(swiper) {
	  const {
	    slidesGrid,
	    params
	  } = swiper;
	  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	  let activeIndex;
	  for (let i = 0; i < slidesGrid.length; i += 1) {
	    if (typeof slidesGrid[i + 1] !== 'undefined') {
	      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
	        activeIndex = i;
	      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
	        activeIndex = i + 1;
	      }
	    } else if (translate >= slidesGrid[i]) {
	      activeIndex = i;
	    }
	  }
	  // Normalize slideIndex
	  if (params.normalizeSlideIndex) {
	    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
	  }
	  return activeIndex;
	}
	function updateActiveIndex(newActiveIndex) {
	  const swiper = this;
	  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	  const {
	    snapGrid,
	    params,
	    activeIndex: previousIndex,
	    realIndex: previousRealIndex,
	    snapIndex: previousSnapIndex
	  } = swiper;
	  let activeIndex = newActiveIndex;
	  let snapIndex;
	  const getVirtualRealIndex = aIndex => {
	    let realIndex = aIndex - swiper.virtual.slidesBefore;
	    if (realIndex < 0) {
	      realIndex = swiper.virtual.slides.length + realIndex;
	    }
	    if (realIndex >= swiper.virtual.slides.length) {
	      realIndex -= swiper.virtual.slides.length;
	    }
	    return realIndex;
	  };
	  if (typeof activeIndex === 'undefined') {
	    activeIndex = getActiveIndexByTranslate(swiper);
	  }
	  if (snapGrid.indexOf(translate) >= 0) {
	    snapIndex = snapGrid.indexOf(translate);
	  } else {
	    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
	    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
	  }
	  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
	  if (activeIndex === previousIndex) {
	    if (snapIndex !== previousSnapIndex) {
	      swiper.snapIndex = snapIndex;
	      swiper.emit('snapIndexChange');
	    }
	    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.realIndex = getVirtualRealIndex(activeIndex);
	    }
	    return;
	  }
	  // Get real index
	  let realIndex;
	  if (swiper.virtual && params.virtual.enabled && params.loop) {
	    realIndex = getVirtualRealIndex(activeIndex);
	  } else if (swiper.slides[activeIndex]) {
	    realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);
	  } else {
	    realIndex = activeIndex;
	  }
	  Object.assign(swiper, {
	    previousSnapIndex,
	    snapIndex,
	    previousRealIndex,
	    realIndex,
	    previousIndex,
	    activeIndex
	  });
	  if (swiper.initialized) {
	    preload(swiper);
	  }
	  swiper.emit('activeIndexChange');
	  swiper.emit('snapIndexChange');
	  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
	    if (previousRealIndex !== realIndex) {
	      swiper.emit('realIndexChange');
	    }
	    swiper.emit('slideChange');
	  }
	}

	function updateClickedSlide(el, path) {
	  const swiper = this;
	  const params = swiper.params;
	  let slide = el.closest(`.${params.slideClass}, swiper-slide`);
	  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
	    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
	      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
	        slide = pathEl;
	      }
	    });
	  }
	  let slideFound = false;
	  let slideIndex;
	  if (slide) {
	    for (let i = 0; i < swiper.slides.length; i += 1) {
	      if (swiper.slides[i] === slide) {
	        slideFound = true;
	        slideIndex = i;
	        break;
	      }
	    }
	  }
	  if (slide && slideFound) {
	    swiper.clickedSlide = slide;
	    if (swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
	    } else {
	      swiper.clickedIndex = slideIndex;
	    }
	  } else {
	    swiper.clickedSlide = undefined;
	    swiper.clickedIndex = undefined;
	    return;
	  }
	  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
	    swiper.slideToClickedSlide();
	  }
	}

	var update = {
	  updateSize,
	  updateSlides,
	  updateAutoHeight,
	  updateSlidesOffset,
	  updateSlidesProgress,
	  updateProgress,
	  updateSlidesClasses,
	  updateActiveIndex,
	  updateClickedSlide
	};

	function getSwiperTranslate(axis) {
	  if (axis === void 0) {
	    axis = this.isHorizontal() ? 'x' : 'y';
	  }
	  const swiper = this;
	  const {
	    params,
	    rtlTranslate: rtl,
	    translate,
	    wrapperEl
	  } = swiper;
	  if (params.virtualTranslate) {
	    return rtl ? -translate : translate;
	  }
	  if (params.cssMode) {
	    return translate;
	  }
	  let currentTranslate = getTranslate(wrapperEl, axis);
	  currentTranslate += swiper.cssOverflowAdjustment();
	  if (rtl) currentTranslate = -currentTranslate;
	  return currentTranslate || 0;
	}

	function setTranslate(translate, byController) {
	  const swiper = this;
	  const {
	    rtlTranslate: rtl,
	    params,
	    wrapperEl,
	    progress
	  } = swiper;
	  let x = 0;
	  let y = 0;
	  const z = 0;
	  if (swiper.isHorizontal()) {
	    x = rtl ? -translate : translate;
	  } else {
	    y = translate;
	  }
	  if (params.roundLengths) {
	    x = Math.floor(x);
	    y = Math.floor(y);
	  }
	  swiper.previousTranslate = swiper.translate;
	  swiper.translate = swiper.isHorizontal() ? x : y;
	  if (params.cssMode) {
	    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
	  } else if (!params.virtualTranslate) {
	    if (swiper.isHorizontal()) {
	      x -= swiper.cssOverflowAdjustment();
	    } else {
	      y -= swiper.cssOverflowAdjustment();
	    }
	    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
	  }

	  // Check if we need to update progress
	  let newProgress;
	  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
	  }
	  if (newProgress !== progress) {
	    swiper.updateProgress(translate);
	  }
	  swiper.emit('setTranslate', swiper.translate, byController);
	}

	function minTranslate() {
	  return -this.snapGrid[0];
	}

	function maxTranslate() {
	  return -this.snapGrid[this.snapGrid.length - 1];
	}

	function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
	  if (translate === void 0) {
	    translate = 0;
	  }
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  if (translateBounds === void 0) {
	    translateBounds = true;
	  }
	  const swiper = this;
	  const {
	    params,
	    wrapperEl
	  } = swiper;
	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return false;
	  }
	  const minTranslate = swiper.minTranslate();
	  const maxTranslate = swiper.maxTranslate();
	  let newTranslate;
	  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

	  // Update progress
	  swiper.updateProgress(newTranslate);
	  if (params.cssMode) {
	    const isH = swiper.isHorizontal();
	    if (speed === 0) {
	      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
	    } else {
	      if (!swiper.support.smoothScroll) {
	        animateCSSModeScroll({
	          swiper,
	          targetPosition: -newTranslate,
	          side: isH ? 'left' : 'top'
	        });
	        return true;
	      }
	      wrapperEl.scrollTo({
	        [isH ? 'left' : 'top']: -newTranslate,
	        behavior: 'smooth'
	      });
	    }
	    return true;
	  }
	  if (speed === 0) {
	    swiper.setTransition(0);
	    swiper.setTranslate(newTranslate);
	    if (runCallbacks) {
	      swiper.emit('beforeTransitionStart', speed, internal);
	      swiper.emit('transitionEnd');
	    }
	  } else {
	    swiper.setTransition(speed);
	    swiper.setTranslate(newTranslate);
	    if (runCallbacks) {
	      swiper.emit('beforeTransitionStart', speed, internal);
	      swiper.emit('transitionStart');
	    }
	    if (!swiper.animating) {
	      swiper.animating = true;
	      if (!swiper.onTranslateToWrapperTransitionEnd) {
	        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
	          if (!swiper || swiper.destroyed) return;
	          if (e.target !== this) return;
	          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
	          swiper.onTranslateToWrapperTransitionEnd = null;
	          delete swiper.onTranslateToWrapperTransitionEnd;
	          if (runCallbacks) {
	            swiper.emit('transitionEnd');
	          }
	        };
	      }
	      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
	    }
	  }
	  return true;
	}

	var translate = {
	  getTranslate: getSwiperTranslate,
	  setTranslate,
	  minTranslate,
	  maxTranslate,
	  translateTo
	};

	function setTransition(duration, byController) {
	  const swiper = this;
	  if (!swiper.params.cssMode) {
	    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
	    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
	  }
	  swiper.emit('setTransition', duration, byController);
	}

	function transitionEmit(_ref) {
	  let {
	    swiper,
	    runCallbacks,
	    direction,
	    step
	  } = _ref;
	  const {
	    activeIndex,
	    previousIndex
	  } = swiper;
	  let dir = direction;
	  if (!dir) {
	    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
	  }
	  swiper.emit(`transition${step}`);
	  if (runCallbacks && activeIndex !== previousIndex) {
	    if (dir === 'reset') {
	      swiper.emit(`slideResetTransition${step}`);
	      return;
	    }
	    swiper.emit(`slideChangeTransition${step}`);
	    if (dir === 'next') {
	      swiper.emit(`slideNextTransition${step}`);
	    } else {
	      swiper.emit(`slidePrevTransition${step}`);
	    }
	  }
	}

	function transitionStart(runCallbacks, direction) {
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  const swiper = this;
	  const {
	    params
	  } = swiper;
	  if (params.cssMode) return;
	  if (params.autoHeight) {
	    swiper.updateAutoHeight();
	  }
	  transitionEmit({
	    swiper,
	    runCallbacks,
	    direction,
	    step: 'Start'
	  });
	}

	function transitionEnd(runCallbacks, direction) {
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  const swiper = this;
	  const {
	    params
	  } = swiper;
	  swiper.animating = false;
	  if (params.cssMode) return;
	  swiper.setTransition(0);
	  transitionEmit({
	    swiper,
	    runCallbacks,
	    direction,
	    step: 'End'
	  });
	}

	var transition = {
	  setTransition,
	  transitionStart,
	  transitionEnd
	};

	function slideTo(index, speed, runCallbacks, internal, initial) {
	  if (index === void 0) {
	    index = 0;
	  }
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  if (typeof index === 'string') {
	    index = parseInt(index, 10);
	  }
	  const swiper = this;
	  let slideIndex = index;
	  if (slideIndex < 0) slideIndex = 0;
	  const {
	    params,
	    snapGrid,
	    slidesGrid,
	    previousIndex,
	    activeIndex,
	    rtlTranslate: rtl,
	    wrapperEl,
	    enabled
	  } = swiper;
	  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
	    return false;
	  }
	  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
	  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
	  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
	  const translate = -snapGrid[snapIndex];
	  // Normalize slideIndex
	  if (params.normalizeSlideIndex) {
	    for (let i = 0; i < slidesGrid.length; i += 1) {
	      const normalizedTranslate = -Math.floor(translate * 100);
	      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
	      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
	      if (typeof slidesGrid[i + 1] !== 'undefined') {
	        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
	          slideIndex = i;
	        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
	          slideIndex = i + 1;
	        }
	      } else if (normalizedTranslate >= normalizedGrid) {
	        slideIndex = i;
	      }
	    }
	  }
	  // Directions locks
	  if (swiper.initialized && slideIndex !== activeIndex) {
	    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
	      return false;
	    }
	    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
	      if ((activeIndex || 0) !== slideIndex) {
	        return false;
	      }
	    }
	  }
	  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
	    swiper.emit('beforeSlideChangeStart');
	  }

	  // Update progress
	  swiper.updateProgress(translate);
	  let direction;
	  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

	  // Update Index
	  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
	    swiper.updateActiveIndex(slideIndex);
	    // Update Height
	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	    swiper.updateSlidesClasses();
	    if (params.effect !== 'slide') {
	      swiper.setTranslate(translate);
	    }
	    if (direction !== 'reset') {
	      swiper.transitionStart(runCallbacks, direction);
	      swiper.transitionEnd(runCallbacks, direction);
	    }
	    return false;
	  }
	  if (params.cssMode) {
	    const isH = swiper.isHorizontal();
	    const t = rtl ? translate : -translate;
	    if (speed === 0) {
	      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	      if (isVirtual) {
	        swiper.wrapperEl.style.scrollSnapType = 'none';
	        swiper._immediateVirtual = true;
	      }
	      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
	        swiper._cssModeVirtualInitialSet = true;
	        requestAnimationFrame(() => {
	          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
	        });
	      } else {
	        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
	      }
	      if (isVirtual) {
	        requestAnimationFrame(() => {
	          swiper.wrapperEl.style.scrollSnapType = '';
	          swiper._immediateVirtual = false;
	        });
	      }
	    } else {
	      if (!swiper.support.smoothScroll) {
	        animateCSSModeScroll({
	          swiper,
	          targetPosition: t,
	          side: isH ? 'left' : 'top'
	        });
	        return true;
	      }
	      wrapperEl.scrollTo({
	        [isH ? 'left' : 'top']: t,
	        behavior: 'smooth'
	      });
	    }
	    return true;
	  }
	  swiper.setTransition(speed);
	  swiper.setTranslate(translate);
	  swiper.updateActiveIndex(slideIndex);
	  swiper.updateSlidesClasses();
	  swiper.emit('beforeTransitionStart', speed, internal);
	  swiper.transitionStart(runCallbacks, direction);
	  if (speed === 0) {
	    swiper.transitionEnd(runCallbacks, direction);
	  } else if (!swiper.animating) {
	    swiper.animating = true;
	    if (!swiper.onSlideToWrapperTransitionEnd) {
	      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
	        if (!swiper || swiper.destroyed) return;
	        if (e.target !== this) return;
	        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	        swiper.onSlideToWrapperTransitionEnd = null;
	        delete swiper.onSlideToWrapperTransitionEnd;
	        swiper.transitionEnd(runCallbacks, direction);
	      };
	    }
	    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	  }
	  return true;
	}

	function slideToLoop(index, speed, runCallbacks, internal) {
	  if (index === void 0) {
	    index = 0;
	  }
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  if (typeof index === 'string') {
	    const indexAsNumber = parseInt(index, 10);
	    index = indexAsNumber;
	  }
	  const swiper = this;
	  let newIndex = index;
	  if (swiper.params.loop) {
	    if (swiper.virtual && swiper.params.virtual.enabled) {
	      // eslint-disable-next-line
	      newIndex = newIndex + swiper.virtual.slidesBefore;
	    } else {
	      newIndex = swiper.getSlideIndexByData(newIndex);
	    }
	  }
	  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideNext(speed, runCallbacks, internal) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  const swiper = this;
	  const {
	    enabled,
	    params,
	    animating
	  } = swiper;
	  if (!enabled) return swiper;
	  let perGroup = params.slidesPerGroup;
	  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
	    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
	  }
	  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
	  const isVirtual = swiper.virtual && params.virtual.enabled;
	  if (params.loop) {
	    if (animating && !isVirtual && params.loopPreventsSliding) return false;
	    swiper.loopFix({
	      direction: 'next'
	    });
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.wrapperEl.clientLeft;
	    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
	      requestAnimationFrame(() => {
	        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
	      });
	      return true;
	    }
	  }
	  if (params.rewind && swiper.isEnd) {
	    return swiper.slideTo(0, speed, runCallbacks, internal);
	  }
	  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slidePrev(speed, runCallbacks, internal) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  const swiper = this;
	  const {
	    params,
	    snapGrid,
	    slidesGrid,
	    rtlTranslate,
	    enabled,
	    animating
	  } = swiper;
	  if (!enabled) return swiper;
	  const isVirtual = swiper.virtual && params.virtual.enabled;
	  if (params.loop) {
	    if (animating && !isVirtual && params.loopPreventsSliding) return false;
	    swiper.loopFix({
	      direction: 'prev'
	    });
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.wrapperEl.clientLeft;
	  }
	  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
	  function normalize(val) {
	    if (val < 0) return -Math.floor(Math.abs(val));
	    return Math.floor(val);
	  }
	  const normalizedTranslate = normalize(translate);
	  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
	  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
	  if (typeof prevSnap === 'undefined' && params.cssMode) {
	    let prevSnapIndex;
	    snapGrid.forEach((snap, snapIndex) => {
	      if (normalizedTranslate >= snap) {
	        // prevSnap = snap;
	        prevSnapIndex = snapIndex;
	      }
	    });
	    if (typeof prevSnapIndex !== 'undefined') {
	      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
	    }
	  }
	  let prevIndex = 0;
	  if (typeof prevSnap !== 'undefined') {
	    prevIndex = slidesGrid.indexOf(prevSnap);
	    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
	    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
	      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
	      prevIndex = Math.max(prevIndex, 0);
	    }
	  }
	  if (params.rewind && swiper.isBeginning) {
	    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
	    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
	  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
	    requestAnimationFrame(() => {
	      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	    });
	    return true;
	  }
	  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideReset(speed, runCallbacks, internal) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  const swiper = this;
	  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	}

	/* eslint no-unused-vars: "off" */
	function slideToClosest(speed, runCallbacks, internal, threshold) {
	  if (speed === void 0) {
	    speed = this.params.speed;
	  }
	  if (runCallbacks === void 0) {
	    runCallbacks = true;
	  }
	  if (threshold === void 0) {
	    threshold = 0.5;
	  }
	  const swiper = this;
	  let index = swiper.activeIndex;
	  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
	  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
	  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	  if (translate >= swiper.snapGrid[snapIndex]) {
	    // The current translate is on or after the current snap index, so the choice
	    // is between the current index and the one after it.
	    const currentSnap = swiper.snapGrid[snapIndex];
	    const nextSnap = swiper.snapGrid[snapIndex + 1];
	    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
	      index += swiper.params.slidesPerGroup;
	    }
	  } else {
	    // The current translate is before the current snap index, so the choice
	    // is between the current index and the one before it.
	    const prevSnap = swiper.snapGrid[snapIndex - 1];
	    const currentSnap = swiper.snapGrid[snapIndex];
	    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
	      index -= swiper.params.slidesPerGroup;
	    }
	  }
	  index = Math.max(index, 0);
	  index = Math.min(index, swiper.slidesGrid.length - 1);
	  return swiper.slideTo(index, speed, runCallbacks, internal);
	}

	function slideToClickedSlide() {
	  const swiper = this;
	  const {
	    params,
	    slidesEl
	  } = swiper;
	  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
	  let slideToIndex = swiper.clickedIndex;
	  let realIndex;
	  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
	  if (params.loop) {
	    if (swiper.animating) return;
	    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
	    if (params.centeredSlides) {
	      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
	        swiper.loopFix();
	        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
	        nextTick(() => {
	          swiper.slideTo(slideToIndex);
	        });
	      } else {
	        swiper.slideTo(slideToIndex);
	      }
	    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
	      swiper.loopFix();
	      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
	      nextTick(() => {
	        swiper.slideTo(slideToIndex);
	      });
	    } else {
	      swiper.slideTo(slideToIndex);
	    }
	  } else {
	    swiper.slideTo(slideToIndex);
	  }
	}

	var slide = {
	  slideTo,
	  slideToLoop,
	  slideNext,
	  slidePrev,
	  slideReset,
	  slideToClosest,
	  slideToClickedSlide
	};

	function loopCreate(slideRealIndex) {
	  const swiper = this;
	  const {
	    params,
	    slidesEl
	  } = swiper;
	  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
	  const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
	  slides.forEach((el, index) => {
	    el.setAttribute('data-swiper-slide-index', index);
	  });
	  swiper.loopFix({
	    slideRealIndex,
	    direction: params.centeredSlides ? undefined : 'next'
	  });
	}

	function loopFix(_temp) {
	  let {
	    slideRealIndex,
	    slideTo = true,
	    direction,
	    setTranslate,
	    activeSlideIndex,
	    byController,
	    byMousewheel
	  } = _temp === void 0 ? {} : _temp;
	  const swiper = this;
	  if (!swiper.params.loop) return;
	  swiper.emit('beforeLoopFix');
	  const {
	    slides,
	    allowSlidePrev,
	    allowSlideNext,
	    slidesEl,
	    params
	  } = swiper;
	  swiper.allowSlidePrev = true;
	  swiper.allowSlideNext = true;
	  if (swiper.virtual && params.virtual.enabled) {
	    if (slideTo) {
	      if (!params.centeredSlides && swiper.snapIndex === 0) {
	        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
	      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
	        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
	      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
	        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
	      }
	    }
	    swiper.allowSlidePrev = allowSlidePrev;
	    swiper.allowSlideNext = allowSlideNext;
	    swiper.emit('loopFix');
	    return;
	  }
	  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
	  let loopedSlides = params.loopedSlides || slidesPerView;
	  if (loopedSlides % params.slidesPerGroup !== 0) {
	    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
	  }
	  swiper.loopedSlides = loopedSlides;
	  const prependSlidesIndexes = [];
	  const appendSlidesIndexes = [];
	  let activeIndex = swiper.activeIndex;
	  if (typeof activeSlideIndex === 'undefined') {
	    activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
	  } else {
	    activeIndex = activeSlideIndex;
	  }
	  const isNext = direction === 'next' || !direction;
	  const isPrev = direction === 'prev' || !direction;
	  let slidesPrepended = 0;
	  let slidesAppended = 0;
	  // prepend last slides before start
	  if (activeSlideIndex < loopedSlides) {
	    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
	    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
	      const index = i - Math.floor(i / slides.length) * slides.length;
	      prependSlidesIndexes.push(slides.length - index - 1);
	    }
	  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {
	    slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
	    for (let i = 0; i < slidesAppended; i += 1) {
	      const index = i - Math.floor(i / slides.length) * slides.length;
	      appendSlidesIndexes.push(index);
	    }
	  }
	  if (isPrev) {
	    prependSlidesIndexes.forEach(index => {
	      swiper.slides[index].swiperLoopMoveDOM = true;
	      slidesEl.prepend(swiper.slides[index]);
	      swiper.slides[index].swiperLoopMoveDOM = false;
	    });
	  }
	  if (isNext) {
	    appendSlidesIndexes.forEach(index => {
	      swiper.slides[index].swiperLoopMoveDOM = true;
	      slidesEl.append(swiper.slides[index]);
	      swiper.slides[index].swiperLoopMoveDOM = false;
	    });
	  }
	  swiper.recalcSlides();
	  if (params.slidesPerView === 'auto') {
	    swiper.updateSlides();
	  }
	  if (params.watchSlidesProgress) {
	    swiper.updateSlidesOffset();
	  }
	  if (slideTo) {
	    if (prependSlidesIndexes.length > 0 && isPrev) {
	      if (typeof slideRealIndex === 'undefined') {
	        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
	        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
	        const diff = newSlideTranslate - currentSlideTranslate;
	        if (byMousewheel) {
	          swiper.setTranslate(swiper.translate - diff);
	        } else {
	          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
	          if (setTranslate) {
	            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
	            swiper.touchEventsData.currentTranslate = swiper.translate;
	          }
	        }
	      } else {
	        if (setTranslate) {
	          swiper.slideToLoop(slideRealIndex, 0, false, true);
	          swiper.touchEventsData.currentTranslate = swiper.translate;
	        }
	      }
	    } else if (appendSlidesIndexes.length > 0 && isNext) {
	      if (typeof slideRealIndex === 'undefined') {
	        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
	        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
	        const diff = newSlideTranslate - currentSlideTranslate;
	        if (byMousewheel) {
	          swiper.setTranslate(swiper.translate - diff);
	        } else {
	          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
	          if (setTranslate) {
	            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
	            swiper.touchEventsData.currentTranslate = swiper.translate;
	          }
	        }
	      } else {
	        swiper.slideToLoop(slideRealIndex, 0, false, true);
	      }
	    }
	  }
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	  if (swiper.controller && swiper.controller.control && !byController) {
	    const loopParams = {
	      slideRealIndex,
	      direction,
	      setTranslate,
	      activeSlideIndex,
	      byController: true
	    };
	    if (Array.isArray(swiper.controller.control)) {
	      swiper.controller.control.forEach(c => {
	        if (!c.destroyed && c.params.loop) c.loopFix({
	          ...loopParams,
	          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
	        });
	      });
	    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
	      swiper.controller.control.loopFix({
	        ...loopParams,
	        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
	      });
	    }
	  }
	  swiper.emit('loopFix');
	}

	function loopDestroy() {
	  const swiper = this;
	  const {
	    params,
	    slidesEl
	  } = swiper;
	  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
	  swiper.recalcSlides();
	  const newSlidesOrder = [];
	  swiper.slides.forEach(slideEl => {
	    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
	    newSlidesOrder[index] = slideEl;
	  });
	  swiper.slides.forEach(slideEl => {
	    slideEl.removeAttribute('data-swiper-slide-index');
	  });
	  newSlidesOrder.forEach(slideEl => {
	    slidesEl.append(slideEl);
	  });
	  swiper.recalcSlides();
	  swiper.slideTo(swiper.realIndex, 0);
	}

	var loop = {
	  loopCreate,
	  loopFix,
	  loopDestroy
	};

	function setGrabCursor(moving) {
	  const swiper = this;
	  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
	  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
	  if (swiper.isElement) {
	    swiper.__preventObserver__ = true;
	  }
	  el.style.cursor = 'move';
	  el.style.cursor = moving ? 'grabbing' : 'grab';
	  if (swiper.isElement) {
	    requestAnimationFrame(() => {
	      swiper.__preventObserver__ = false;
	    });
	  }
	}

	function unsetGrabCursor() {
	  const swiper = this;
	  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
	    return;
	  }
	  if (swiper.isElement) {
	    swiper.__preventObserver__ = true;
	  }
	  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
	  if (swiper.isElement) {
	    requestAnimationFrame(() => {
	      swiper.__preventObserver__ = false;
	    });
	  }
	}

	var grabCursor = {
	  setGrabCursor,
	  unsetGrabCursor
	};

	// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
	function closestElement(selector, base) {
	  if (base === void 0) {
	    base = this;
	  }
	  function __closestFrom(el) {
	    if (!el || el === getDocument() || el === getWindow()) return null;
	    if (el.assignedSlot) el = el.assignedSlot;
	    const found = el.closest(selector);
	    if (!found && !el.getRootNode) {
	      return null;
	    }
	    return found || __closestFrom(el.getRootNode().host);
	  }
	  return __closestFrom(base);
	}
	function onTouchStart(event) {
	  const swiper = this;
	  const document = getDocument();
	  const window = getWindow();
	  const data = swiper.touchEventsData;
	  data.evCache.push(event);
	  const {
	    params,
	    touches,
	    enabled
	  } = swiper;
	  if (!enabled) return;
	  if (!params.simulateTouch && event.pointerType === 'mouse') return;
	  if (swiper.animating && params.preventInteractionOnTransition) {
	    return;
	  }
	  if (!swiper.animating && params.cssMode && params.loop) {
	    swiper.loopFix();
	  }
	  let e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  let targetEl = e.target;
	  if (params.touchEventsTarget === 'wrapper') {
	    if (!swiper.wrapperEl.contains(targetEl)) return;
	  }
	  if ('which' in e && e.which === 3) return;
	  if ('button' in e && e.button > 0) return;
	  if (data.isTouched && data.isMoved) return;

	  // change target el for shadow root component
	  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
	  // eslint-disable-next-line
	  const eventPath = event.composedPath ? event.composedPath() : event.path;
	  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
	    targetEl = eventPath[0];
	  }
	  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
	  const isTargetShadow = !!(e.target && e.target.shadowRoot);

	  // use closestElement for shadow root element to get the actual closest for nested shadow root element
	  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
	    swiper.allowClick = true;
	    return;
	  }
	  if (params.swipeHandler) {
	    if (!targetEl.closest(params.swipeHandler)) return;
	  }
	  touches.currentX = e.pageX;
	  touches.currentY = e.pageY;
	  const startX = touches.currentX;
	  const startY = touches.currentY;

	  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

	  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
	  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
	  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
	    if (edgeSwipeDetection === 'prevent') {
	      event.preventDefault();
	    } else {
	      return;
	    }
	  }
	  Object.assign(data, {
	    isTouched: true,
	    isMoved: false,
	    allowTouchCallbacks: true,
	    isScrolling: undefined,
	    startMoving: undefined
	  });
	  touches.startX = startX;
	  touches.startY = startY;
	  data.touchStartTime = now();
	  swiper.allowClick = true;
	  swiper.updateSize();
	  swiper.swipeDirection = undefined;
	  if (params.threshold > 0) data.allowThresholdMove = false;
	  let preventDefault = true;
	  if (targetEl.matches(data.focusableElements)) {
	    preventDefault = false;
	    if (targetEl.nodeName === 'SELECT') {
	      data.isTouched = false;
	    }
	  }
	  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
	    document.activeElement.blur();
	  }
	  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
	  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
	    e.preventDefault();
	  }
	  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
	    swiper.freeMode.onTouchStart();
	  }
	  swiper.emit('touchStart', e);
	}

	function onTouchMove(event) {
	  const document = getDocument();
	  const swiper = this;
	  const data = swiper.touchEventsData;
	  const {
	    params,
	    touches,
	    rtlTranslate: rtl,
	    enabled
	  } = swiper;
	  if (!enabled) return;
	  if (!params.simulateTouch && event.pointerType === 'mouse') return;
	  let e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  if (!data.isTouched) {
	    if (data.startMoving && data.isScrolling) {
	      swiper.emit('touchMoveOpposite', e);
	    }
	    return;
	  }
	  const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
	  if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
	  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
	  const pageX = targetTouch.pageX;
	  const pageY = targetTouch.pageY;
	  if (e.preventedByNestedSwiper) {
	    touches.startX = pageX;
	    touches.startY = pageY;
	    return;
	  }
	  if (!swiper.allowTouchMove) {
	    if (!e.target.matches(data.focusableElements)) {
	      swiper.allowClick = false;
	    }
	    if (data.isTouched) {
	      Object.assign(touches, {
	        startX: pageX,
	        startY: pageY,
	        prevX: swiper.touches.currentX,
	        prevY: swiper.touches.currentY,
	        currentX: pageX,
	        currentY: pageY
	      });
	      data.touchStartTime = now();
	    }
	    return;
	  }
	  if (params.touchReleaseOnEdges && !params.loop) {
	    if (swiper.isVertical()) {
	      // Vertical
	      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
	        data.isTouched = false;
	        data.isMoved = false;
	        return;
	      }
	    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
	      return;
	    }
	  }
	  if (document.activeElement) {
	    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
	      data.isMoved = true;
	      swiper.allowClick = false;
	      return;
	    }
	  }
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchMove', e);
	  }
	  if (e.targetTouches && e.targetTouches.length > 1) return;
	  touches.currentX = pageX;
	  touches.currentY = pageY;
	  const diffX = touches.currentX - touches.startX;
	  const diffY = touches.currentY - touches.startY;
	  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
	  if (typeof data.isScrolling === 'undefined') {
	    let touchAngle;
	    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
	      data.isScrolling = false;
	    } else {
	      // eslint-disable-next-line
	      if (diffX * diffX + diffY * diffY >= 25) {
	        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
	        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
	      }
	    }
	  }
	  if (data.isScrolling) {
	    swiper.emit('touchMoveOpposite', e);
	  }
	  if (typeof data.startMoving === 'undefined') {
	    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
	      data.startMoving = true;
	    }
	  }
	  if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
	    data.isTouched = false;
	    return;
	  }
	  if (!data.startMoving) {
	    return;
	  }
	  swiper.allowClick = false;
	  if (!params.cssMode && e.cancelable) {
	    e.preventDefault();
	  }
	  if (params.touchMoveStopPropagation && !params.nested) {
	    e.stopPropagation();
	  }
	  let diff = swiper.isHorizontal() ? diffX : diffY;
	  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
	  if (params.oneWayMovement) {
	    diff = Math.abs(diff) * (rtl ? 1 : -1);
	    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
	  }
	  touches.diff = diff;
	  diff *= params.touchRatio;
	  if (rtl) {
	    diff = -diff;
	    touchesDiff = -touchesDiff;
	  }
	  const prevTouchesDirection = swiper.touchesDirection;
	  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
	  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
	  const isLoop = swiper.params.loop && !params.cssMode;
	  const allowLoopFix = swiper.swipeDirection === 'next' && swiper.allowSlideNext || swiper.swipeDirection === 'prev' && swiper.allowSlidePrev;
	  if (!data.isMoved) {
	    if (isLoop && allowLoopFix) {
	      swiper.loopFix({
	        direction: swiper.swipeDirection
	      });
	    }
	    data.startTranslate = swiper.getTranslate();
	    swiper.setTransition(0);
	    if (swiper.animating) {
	      const evt = new window.CustomEvent('transitionend', {
	        bubbles: true,
	        cancelable: true
	      });
	      swiper.wrapperEl.dispatchEvent(evt);
	    }
	    data.allowMomentumBounce = false;
	    // Grab Cursor
	    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	      swiper.setGrabCursor(true);
	    }
	    swiper.emit('sliderFirstMove', e);
	  }
	  let loopFixed;
	  if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
	    // need another loop fix
	    swiper.loopFix({
	      direction: swiper.swipeDirection,
	      setTranslate: true
	    });
	    loopFixed = true;
	  }
	  swiper.emit('sliderMove', e);
	  data.isMoved = true;
	  data.currentTranslate = diff + data.startTranslate;
	  let disableParentSwiper = true;
	  let resistanceRatio = params.resistanceRatio;
	  if (params.touchReleaseOnEdges) {
	    resistanceRatio = 0;
	  }
	  if (diff > 0) {
	    if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {
	      swiper.loopFix({
	        direction: 'prev',
	        setTranslate: true,
	        activeSlideIndex: 0
	      });
	    }
	    if (data.currentTranslate > swiper.minTranslate()) {
	      disableParentSwiper = false;
	      if (params.resistance) {
	        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
	      }
	    }
	  } else if (diff < 0) {
	    if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {
	      swiper.loopFix({
	        direction: 'next',
	        setTranslate: true,
	        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
	      });
	    }
	    if (data.currentTranslate < swiper.maxTranslate()) {
	      disableParentSwiper = false;
	      if (params.resistance) {
	        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
	      }
	    }
	  }
	  if (disableParentSwiper) {
	    e.preventedByNestedSwiper = true;
	  }

	  // Directions locks
	  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }
	  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }
	  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
	    data.currentTranslate = data.startTranslate;
	  }

	  // Threshold
	  if (params.threshold > 0) {
	    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
	      if (!data.allowThresholdMove) {
	        data.allowThresholdMove = true;
	        touches.startX = touches.currentX;
	        touches.startY = touches.currentY;
	        data.currentTranslate = data.startTranslate;
	        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
	        return;
	      }
	    } else {
	      data.currentTranslate = data.startTranslate;
	      return;
	    }
	  }
	  if (!params.followFinger || params.cssMode) return;

	  // Update active index in free mode
	  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }
	  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
	    swiper.freeMode.onTouchMove();
	  }
	  // Update progress
	  swiper.updateProgress(data.currentTranslate);
	  // Update translate
	  swiper.setTranslate(data.currentTranslate);
	}

	function onTouchEnd(event) {
	  const swiper = this;
	  const data = swiper.touchEventsData;
	  const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);
	  if (pointerIndex >= 0) {
	    data.evCache.splice(pointerIndex, 1);
	  }
	  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(event.type)) {
	    const proceed = ['pointercancel', 'contextmenu'].includes(event.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
	    if (!proceed) {
	      return;
	    }
	  }
	  const {
	    params,
	    touches,
	    rtlTranslate: rtl,
	    slidesGrid,
	    enabled
	  } = swiper;
	  if (!enabled) return;
	  if (!params.simulateTouch && event.pointerType === 'mouse') return;
	  let e = event;
	  if (e.originalEvent) e = e.originalEvent;
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchEnd', e);
	  }
	  data.allowTouchCallbacks = false;
	  if (!data.isTouched) {
	    if (data.isMoved && params.grabCursor) {
	      swiper.setGrabCursor(false);
	    }
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }
	  // Return Grab Cursor
	  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	    swiper.setGrabCursor(false);
	  }

	  // Time diff
	  const touchEndTime = now();
	  const timeDiff = touchEndTime - data.touchStartTime;

	  // Tap, doubleTap, Click
	  if (swiper.allowClick) {
	    const pathTree = e.path || e.composedPath && e.composedPath();
	    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
	    swiper.emit('tap click', e);
	    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
	      swiper.emit('doubleTap doubleClick', e);
	    }
	  }
	  data.lastClickTime = now();
	  nextTick(() => {
	    if (!swiper.destroyed) swiper.allowClick = true;
	  });
	  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
	    data.isTouched = false;
	    data.isMoved = false;
	    data.startMoving = false;
	    return;
	  }
	  data.isTouched = false;
	  data.isMoved = false;
	  data.startMoving = false;
	  let currentPos;
	  if (params.followFinger) {
	    currentPos = rtl ? swiper.translate : -swiper.translate;
	  } else {
	    currentPos = -data.currentTranslate;
	  }
	  if (params.cssMode) {
	    return;
	  }
	  if (params.freeMode && params.freeMode.enabled) {
	    swiper.freeMode.onTouchEnd({
	      currentPos
	    });
	    return;
	  }

	  // Find current slide
	  let stopIndex = 0;
	  let groupSize = swiper.slidesSizesGrid[0];
	  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
	    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
	    if (typeof slidesGrid[i + increment] !== 'undefined') {
	      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
	        stopIndex = i;
	        groupSize = slidesGrid[i + increment] - slidesGrid[i];
	      }
	    } else if (currentPos >= slidesGrid[i]) {
	      stopIndex = i;
	      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
	    }
	  }
	  let rewindFirstIndex = null;
	  let rewindLastIndex = null;
	  if (params.rewind) {
	    if (swiper.isBeginning) {
	      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
	    } else if (swiper.isEnd) {
	      rewindFirstIndex = 0;
	    }
	  }
	  // Find current slide size
	  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
	  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
	  if (timeDiff > params.longSwipesMs) {
	    // Long touches
	    if (!params.longSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
	    }
	    if (swiper.swipeDirection === 'prev') {
	      if (ratio > 1 - params.longSwipesRatio) {
	        swiper.slideTo(stopIndex + increment);
	      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
	        swiper.slideTo(rewindLastIndex);
	      } else {
	        swiper.slideTo(stopIndex);
	      }
	    }
	  } else {
	    // Short swipes
	    if (!params.shortSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
	    if (!isNavButtonTarget) {
	      if (swiper.swipeDirection === 'next') {
	        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
	      }
	      if (swiper.swipeDirection === 'prev') {
	        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
	      }
	    } else if (e.target === swiper.navigation.nextEl) {
	      swiper.slideTo(stopIndex + increment);
	    } else {
	      swiper.slideTo(stopIndex);
	    }
	  }
	}

	function onResize() {
	  const swiper = this;
	  const {
	    params,
	    el
	  } = swiper;
	  if (el && el.offsetWidth === 0) return;

	  // Breakpoints
	  if (params.breakpoints) {
	    swiper.setBreakpoint();
	  }

	  // Save locks
	  const {
	    allowSlideNext,
	    allowSlidePrev,
	    snapGrid
	  } = swiper;
	  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

	  // Disable locks on resize
	  swiper.allowSlideNext = true;
	  swiper.allowSlidePrev = true;
	  swiper.updateSize();
	  swiper.updateSlides();
	  swiper.updateSlidesClasses();
	  const isVirtualLoop = isVirtual && params.loop;
	  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
	    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	  } else {
	    if (swiper.params.loop && !isVirtual) {
	      swiper.slideToLoop(swiper.realIndex, 0, false, true);
	    } else {
	      swiper.slideTo(swiper.activeIndex, 0, false, true);
	    }
	  }
	  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
	    clearTimeout(swiper.autoplay.resizeTimeout);
	    swiper.autoplay.resizeTimeout = setTimeout(() => {
	      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
	        swiper.autoplay.resume();
	      }
	    }, 500);
	  }
	  // Return locks after resize
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
	    swiper.checkOverflow();
	  }
	}

	function onClick(e) {
	  const swiper = this;
	  if (!swiper.enabled) return;
	  if (!swiper.allowClick) {
	    if (swiper.params.preventClicks) e.preventDefault();
	    if (swiper.params.preventClicksPropagation && swiper.animating) {
	      e.stopPropagation();
	      e.stopImmediatePropagation();
	    }
	  }
	}

	function onScroll() {
	  const swiper = this;
	  const {
	    wrapperEl,
	    rtlTranslate,
	    enabled
	  } = swiper;
	  if (!enabled) return;
	  swiper.previousTranslate = swiper.translate;
	  if (swiper.isHorizontal()) {
	    swiper.translate = -wrapperEl.scrollLeft;
	  } else {
	    swiper.translate = -wrapperEl.scrollTop;
	  }
	  // eslint-disable-next-line
	  if (swiper.translate === 0) swiper.translate = 0;
	  swiper.updateActiveIndex();
	  swiper.updateSlidesClasses();
	  let newProgress;
	  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
	  }
	  if (newProgress !== swiper.progress) {
	    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
	  }
	  swiper.emit('setTranslate', swiper.translate, false);
	}

	function onLoad(e) {
	  const swiper = this;
	  processLazyPreloader(swiper, e.target);
	  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
	    return;
	  }
	  swiper.update();
	}

	let dummyEventAttached = false;
	function dummyEventListener() {}
	const events = (swiper, method) => {
	  const document = getDocument();
	  const {
	    params,
	    el,
	    wrapperEl,
	    device
	  } = swiper;
	  const capture = !!params.nested;
	  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
	  const swiperMethod = method;

	  // Touch Events
	  el[domMethod]('pointerdown', swiper.onTouchStart, {
	    passive: false
	  });
	  document[domMethod]('pointermove', swiper.onTouchMove, {
	    passive: false,
	    capture
	  });
	  document[domMethod]('pointerup', swiper.onTouchEnd, {
	    passive: true
	  });
	  document[domMethod]('pointercancel', swiper.onTouchEnd, {
	    passive: true
	  });
	  document[domMethod]('pointerout', swiper.onTouchEnd, {
	    passive: true
	  });
	  document[domMethod]('pointerleave', swiper.onTouchEnd, {
	    passive: true
	  });
	  document[domMethod]('contextmenu', swiper.onTouchEnd, {
	    passive: true
	  });

	  // Prevent Links Clicks
	  if (params.preventClicks || params.preventClicksPropagation) {
	    el[domMethod]('click', swiper.onClick, true);
	  }
	  if (params.cssMode) {
	    wrapperEl[domMethod]('scroll', swiper.onScroll);
	  }

	  // Resize handler
	  if (params.updateOnWindowResize) {
	    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
	  } else {
	    swiper[swiperMethod]('observerUpdate', onResize, true);
	  }

	  // Images loader
	  el[domMethod]('load', swiper.onLoad, {
	    capture: true
	  });
	};
	function attachEvents() {
	  const swiper = this;
	  const document = getDocument();
	  const {
	    params
	  } = swiper;
	  swiper.onTouchStart = onTouchStart.bind(swiper);
	  swiper.onTouchMove = onTouchMove.bind(swiper);
	  swiper.onTouchEnd = onTouchEnd.bind(swiper);
	  if (params.cssMode) {
	    swiper.onScroll = onScroll.bind(swiper);
	  }
	  swiper.onClick = onClick.bind(swiper);
	  swiper.onLoad = onLoad.bind(swiper);
	  if (!dummyEventAttached) {
	    document.addEventListener('touchstart', dummyEventListener);
	    dummyEventAttached = true;
	  }
	  events(swiper, 'on');
	}
	function detachEvents() {
	  const swiper = this;
	  events(swiper, 'off');
	}
	var events$1 = {
	  attachEvents,
	  detachEvents
	};

	const isGridEnabled = (swiper, params) => {
	  return swiper.grid && params.grid && params.grid.rows > 1;
	};
	function setBreakpoint() {
	  const swiper = this;
	  const {
	    realIndex,
	    initialized,
	    params,
	    el
	  } = swiper;
	  const breakpoints = params.breakpoints;
	  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

	  // Get breakpoint for window width and update parameters
	  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
	  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
	  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
	  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
	  const wasMultiRow = isGridEnabled(swiper, params);
	  const isMultiRow = isGridEnabled(swiper, breakpointParams);
	  const wasEnabled = params.enabled;
	  if (wasMultiRow && !isMultiRow) {
	    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
	    swiper.emitContainerClasses();
	  } else if (!wasMultiRow && isMultiRow) {
	    el.classList.add(`${params.containerModifierClass}grid`);
	    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
	      el.classList.add(`${params.containerModifierClass}grid-column`);
	    }
	    swiper.emitContainerClasses();
	  }

	  // Toggle navigation, pagination, scrollbar
	  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
	    if (typeof breakpointParams[prop] === 'undefined') return;
	    const wasModuleEnabled = params[prop] && params[prop].enabled;
	    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
	    if (wasModuleEnabled && !isModuleEnabled) {
	      swiper[prop].disable();
	    }
	    if (!wasModuleEnabled && isModuleEnabled) {
	      swiper[prop].enable();
	    }
	  });
	  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
	  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
	  const wasLoop = params.loop;
	  if (directionChanged && initialized) {
	    swiper.changeDirection();
	  }
	  extend(swiper.params, breakpointParams);
	  const isEnabled = swiper.params.enabled;
	  const hasLoop = swiper.params.loop;
	  Object.assign(swiper, {
	    allowTouchMove: swiper.params.allowTouchMove,
	    allowSlideNext: swiper.params.allowSlideNext,
	    allowSlidePrev: swiper.params.allowSlidePrev
	  });
	  if (wasEnabled && !isEnabled) {
	    swiper.disable();
	  } else if (!wasEnabled && isEnabled) {
	    swiper.enable();
	  }
	  swiper.currentBreakpoint = breakpoint;
	  swiper.emit('_beforeBreakpoint', breakpointParams);
	  if (initialized) {
	    if (needsReLoop) {
	      swiper.loopDestroy();
	      swiper.loopCreate(realIndex);
	      swiper.updateSlides();
	    } else if (!wasLoop && hasLoop) {
	      swiper.loopCreate(realIndex);
	      swiper.updateSlides();
	    } else if (wasLoop && !hasLoop) {
	      swiper.loopDestroy();
	    }
	  }
	  swiper.emit('breakpoint', breakpointParams);
	}

	function getBreakpoint(breakpoints, base, containerEl) {
	  if (base === void 0) {
	    base = 'window';
	  }
	  if (!breakpoints || base === 'container' && !containerEl) return undefined;
	  let breakpoint = false;
	  const window = getWindow();
	  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
	  const points = Object.keys(breakpoints).map(point => {
	    if (typeof point === 'string' && point.indexOf('@') === 0) {
	      const minRatio = parseFloat(point.substr(1));
	      const value = currentHeight * minRatio;
	      return {
	        value,
	        point
	      };
	    }
	    return {
	      value: point,
	      point
	    };
	  });
	  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
	  for (let i = 0; i < points.length; i += 1) {
	    const {
	      point,
	      value
	    } = points[i];
	    if (base === 'window') {
	      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
	        breakpoint = point;
	      }
	    } else if (value <= containerEl.clientWidth) {
	      breakpoint = point;
	    }
	  }
	  return breakpoint || 'max';
	}

	var breakpoints = {
	  setBreakpoint,
	  getBreakpoint
	};

	function prepareClasses(entries, prefix) {
	  const resultClasses = [];
	  entries.forEach(item => {
	    if (typeof item === 'object') {
	      Object.keys(item).forEach(classNames => {
	        if (item[classNames]) {
	          resultClasses.push(prefix + classNames);
	        }
	      });
	    } else if (typeof item === 'string') {
	      resultClasses.push(prefix + item);
	    }
	  });
	  return resultClasses;
	}
	function addClasses() {
	  const swiper = this;
	  const {
	    classNames,
	    params,
	    rtl,
	    el,
	    device
	  } = swiper;
	  // prettier-ignore
	  const suffixes = prepareClasses(['initialized', params.direction, {
	    'free-mode': swiper.params.freeMode && params.freeMode.enabled
	  }, {
	    'autoheight': params.autoHeight
	  }, {
	    'rtl': rtl
	  }, {
	    'grid': params.grid && params.grid.rows > 1
	  }, {
	    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
	  }, {
	    'android': device.android
	  }, {
	    'ios': device.ios
	  }, {
	    'css-mode': params.cssMode
	  }, {
	    'centered': params.cssMode && params.centeredSlides
	  }, {
	    'watch-progress': params.watchSlidesProgress
	  }], params.containerModifierClass);
	  classNames.push(...suffixes);
	  el.classList.add(...classNames);
	  swiper.emitContainerClasses();
	}

	function removeClasses() {
	  const swiper = this;
	  const {
	    el,
	    classNames
	  } = swiper;
	  el.classList.remove(...classNames);
	  swiper.emitContainerClasses();
	}

	var classes = {
	  addClasses,
	  removeClasses
	};

	function checkOverflow() {
	  const swiper = this;
	  const {
	    isLocked: wasLocked,
	    params
	  } = swiper;
	  const {
	    slidesOffsetBefore
	  } = params;
	  if (slidesOffsetBefore) {
	    const lastSlideIndex = swiper.slides.length - 1;
	    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
	    swiper.isLocked = swiper.size > lastSlideRightEdge;
	  } else {
	    swiper.isLocked = swiper.snapGrid.length === 1;
	  }
	  if (params.allowSlideNext === true) {
	    swiper.allowSlideNext = !swiper.isLocked;
	  }
	  if (params.allowSlidePrev === true) {
	    swiper.allowSlidePrev = !swiper.isLocked;
	  }
	  if (wasLocked && wasLocked !== swiper.isLocked) {
	    swiper.isEnd = false;
	  }
	  if (wasLocked !== swiper.isLocked) {
	    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
	  }
	}
	var checkOverflow$1 = {
	  checkOverflow
	};

	var defaults = {
	  init: true,
	  direction: 'horizontal',
	  oneWayMovement: false,
	  touchEventsTarget: 'wrapper',
	  initialSlide: 0,
	  speed: 300,
	  cssMode: false,
	  updateOnWindowResize: true,
	  resizeObserver: true,
	  nested: false,
	  createElements: false,
	  enabled: true,
	  focusableElements: 'input, select, option, textarea, button, video, label',
	  // Overrides
	  width: null,
	  height: null,
	  //
	  preventInteractionOnTransition: false,
	  // ssr
	  userAgent: null,
	  url: null,
	  // To support iOS's swipe-to-go-back gesture (when being used in-app).
	  edgeSwipeDetection: false,
	  edgeSwipeThreshold: 20,
	  // Autoheight
	  autoHeight: false,
	  // Set wrapper width
	  setWrapperSize: false,
	  // Virtual Translate
	  virtualTranslate: false,
	  // Effects
	  effect: 'slide',
	  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

	  // Breakpoints
	  breakpoints: undefined,
	  breakpointsBase: 'window',
	  // Slides grid
	  spaceBetween: 0,
	  slidesPerView: 1,
	  slidesPerGroup: 1,
	  slidesPerGroupSkip: 0,
	  slidesPerGroupAuto: false,
	  centeredSlides: false,
	  centeredSlidesBounds: false,
	  slidesOffsetBefore: 0,
	  // in px
	  slidesOffsetAfter: 0,
	  // in px
	  normalizeSlideIndex: true,
	  centerInsufficientSlides: false,
	  // Disable swiper and hide navigation when container not overflow
	  watchOverflow: true,
	  // Round length
	  roundLengths: false,
	  // Touches
	  touchRatio: 1,
	  touchAngle: 45,
	  simulateTouch: true,
	  shortSwipes: true,
	  longSwipes: true,
	  longSwipesRatio: 0.5,
	  longSwipesMs: 300,
	  followFinger: true,
	  allowTouchMove: true,
	  threshold: 5,
	  touchMoveStopPropagation: false,
	  touchStartPreventDefault: true,
	  touchStartForcePreventDefault: false,
	  touchReleaseOnEdges: false,
	  // Unique Navigation Elements
	  uniqueNavElements: true,
	  // Resistance
	  resistance: true,
	  resistanceRatio: 0.85,
	  // Progress
	  watchSlidesProgress: false,
	  // Cursor
	  grabCursor: false,
	  // Clicks
	  preventClicks: true,
	  preventClicksPropagation: true,
	  slideToClickedSlide: false,
	  // loop
	  loop: false,
	  loopedSlides: null,
	  loopPreventsSliding: true,
	  // rewind
	  rewind: false,
	  // Swiping/no swiping
	  allowSlidePrev: true,
	  allowSlideNext: true,
	  swipeHandler: null,
	  // '.swipe-handler',
	  noSwiping: true,
	  noSwipingClass: 'swiper-no-swiping',
	  noSwipingSelector: null,
	  // Passive Listeners
	  passiveListeners: true,
	  maxBackfaceHiddenSlides: 10,
	  // NS
	  containerModifierClass: 'swiper-',
	  // NEW
	  slideClass: 'swiper-slide',
	  slideActiveClass: 'swiper-slide-active',
	  slideVisibleClass: 'swiper-slide-visible',
	  slideNextClass: 'swiper-slide-next',
	  slidePrevClass: 'swiper-slide-prev',
	  wrapperClass: 'swiper-wrapper',
	  lazyPreloaderClass: 'swiper-lazy-preloader',
	  lazyPreloadPrevNext: 0,
	  // Callbacks
	  runCallbacksOnInit: true,
	  // Internals
	  _emitClasses: false
	};

	function moduleExtendParams(params, allModulesParams) {
	  return function extendParams(obj) {
	    if (obj === void 0) {
	      obj = {};
	    }
	    const moduleParamName = Object.keys(obj)[0];
	    const moduleParams = obj[moduleParamName];
	    if (typeof moduleParams !== 'object' || moduleParams === null) {
	      extend(allModulesParams, obj);
	      return;
	    }
	    if (params[moduleParamName] === true) {
	      params[moduleParamName] = {
	        enabled: true
	      };
	    }
	    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
	      params[moduleParamName].auto = true;
	    }
	    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
	      params[moduleParamName].auto = true;
	    }
	    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
	      extend(allModulesParams, obj);
	      return;
	    }
	    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
	      params[moduleParamName].enabled = true;
	    }
	    if (!params[moduleParamName]) params[moduleParamName] = {
	      enabled: false
	    };
	    extend(allModulesParams, obj);
	  };
	}

	/* eslint no-param-reassign: "off" */
	const prototypes = {
	  eventsEmitter,
	  update,
	  translate,
	  transition,
	  slide,
	  loop,
	  grabCursor,
	  events: events$1,
	  breakpoints,
	  checkOverflow: checkOverflow$1,
	  classes
	};
	const extendedDefaults = {};
	class Swiper {
	  constructor() {
	    let el;
	    let params;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
	      params = args[0];
	    } else {
	      [el, params] = args;
	    }
	    if (!params) params = {};
	    params = extend({}, params);
	    if (el && !params.el) params.el = el;
	    const document = getDocument();
	    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
	      const swipers = [];
	      document.querySelectorAll(params.el).forEach(containerEl => {
	        const newParams = extend({}, params, {
	          el: containerEl
	        });
	        swipers.push(new Swiper(newParams));
	      });
	      // eslint-disable-next-line no-constructor-return
	      return swipers;
	    }

	    // Swiper Instance
	    const swiper = this;
	    swiper.__swiper__ = true;
	    swiper.support = getSupport();
	    swiper.device = getDevice({
	      userAgent: params.userAgent
	    });
	    swiper.browser = getBrowser();
	    swiper.eventsListeners = {};
	    swiper.eventsAnyListeners = [];
	    swiper.modules = [...swiper.__modules__];
	    if (params.modules && Array.isArray(params.modules)) {
	      swiper.modules.push(...params.modules);
	    }
	    const allModulesParams = {};
	    swiper.modules.forEach(mod => {
	      mod({
	        params,
	        swiper,
	        extendParams: moduleExtendParams(params, allModulesParams),
	        on: swiper.on.bind(swiper),
	        once: swiper.once.bind(swiper),
	        off: swiper.off.bind(swiper),
	        emit: swiper.emit.bind(swiper)
	      });
	    });

	    // Extend defaults with modules params
	    const swiperParams = extend({}, defaults, allModulesParams);

	    // Extend defaults with passed params
	    swiper.params = extend({}, swiperParams, extendedDefaults, params);
	    swiper.originalParams = extend({}, swiper.params);
	    swiper.passedParams = extend({}, params);

	    // add event listeners
	    if (swiper.params && swiper.params.on) {
	      Object.keys(swiper.params.on).forEach(eventName => {
	        swiper.on(eventName, swiper.params.on[eventName]);
	      });
	    }
	    if (swiper.params && swiper.params.onAny) {
	      swiper.onAny(swiper.params.onAny);
	    }

	    // Extend Swiper
	    Object.assign(swiper, {
	      enabled: swiper.params.enabled,
	      el,
	      // Classes
	      classNames: [],
	      // Slides
	      slides: [],
	      slidesGrid: [],
	      snapGrid: [],
	      slidesSizesGrid: [],
	      // isDirection
	      isHorizontal() {
	        return swiper.params.direction === 'horizontal';
	      },
	      isVertical() {
	        return swiper.params.direction === 'vertical';
	      },
	      // Indexes
	      activeIndex: 0,
	      realIndex: 0,
	      //
	      isBeginning: true,
	      isEnd: false,
	      // Props
	      translate: 0,
	      previousTranslate: 0,
	      progress: 0,
	      velocity: 0,
	      animating: false,
	      cssOverflowAdjustment() {
	        // Returns 0 unless `translate` is > 2**23
	        // Should be subtracted from css values to prevent overflow
	        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
	      },
	      // Locks
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,
	      // Touch Events
	      touchEventsData: {
	        isTouched: undefined,
	        isMoved: undefined,
	        allowTouchCallbacks: undefined,
	        touchStartTime: undefined,
	        isScrolling: undefined,
	        currentTranslate: undefined,
	        startTranslate: undefined,
	        allowThresholdMove: undefined,
	        // Form elements to match
	        focusableElements: swiper.params.focusableElements,
	        // Last click time
	        lastClickTime: 0,
	        clickTimeout: undefined,
	        // Velocities
	        velocities: [],
	        allowMomentumBounce: undefined,
	        startMoving: undefined,
	        evCache: []
	      },
	      // Clicks
	      allowClick: true,
	      // Touches
	      allowTouchMove: swiper.params.allowTouchMove,
	      touches: {
	        startX: 0,
	        startY: 0,
	        currentX: 0,
	        currentY: 0,
	        diff: 0
	      },
	      // Images
	      imagesToLoad: [],
	      imagesLoaded: 0
	    });
	    swiper.emit('_swiper');

	    // Init
	    if (swiper.params.init) {
	      swiper.init();
	    }

	    // Return app instance
	    // eslint-disable-next-line no-constructor-return
	    return swiper;
	  }
	  getSlideIndex(slideEl) {
	    const {
	      slidesEl,
	      params
	    } = this;
	    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
	    const firstSlideIndex = elementIndex(slides[0]);
	    return elementIndex(slideEl) - firstSlideIndex;
	  }
	  getSlideIndexByData(index) {
	    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
	  }
	  recalcSlides() {
	    const swiper = this;
	    const {
	      slidesEl,
	      params
	    } = swiper;
	    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
	  }
	  enable() {
	    const swiper = this;
	    if (swiper.enabled) return;
	    swiper.enabled = true;
	    if (swiper.params.grabCursor) {
	      swiper.setGrabCursor();
	    }
	    swiper.emit('enable');
	  }
	  disable() {
	    const swiper = this;
	    if (!swiper.enabled) return;
	    swiper.enabled = false;
	    if (swiper.params.grabCursor) {
	      swiper.unsetGrabCursor();
	    }
	    swiper.emit('disable');
	  }
	  setProgress(progress, speed) {
	    const swiper = this;
	    progress = Math.min(Math.max(progress, 0), 1);
	    const min = swiper.minTranslate();
	    const max = swiper.maxTranslate();
	    const current = (max - min) * progress + min;
	    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }
	  emitContainerClasses() {
	    const swiper = this;
	    if (!swiper.params._emitClasses || !swiper.el) return;
	    const cls = swiper.el.className.split(' ').filter(className => {
	      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
	    });
	    swiper.emit('_containerClasses', cls.join(' '));
	  }
	  getSlideClasses(slideEl) {
	    const swiper = this;
	    if (swiper.destroyed) return '';
	    return slideEl.className.split(' ').filter(className => {
	      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
	    }).join(' ');
	  }
	  emitSlidesClasses() {
	    const swiper = this;
	    if (!swiper.params._emitClasses || !swiper.el) return;
	    const updates = [];
	    swiper.slides.forEach(slideEl => {
	      const classNames = swiper.getSlideClasses(slideEl);
	      updates.push({
	        slideEl,
	        classNames
	      });
	      swiper.emit('_slideClass', slideEl, classNames);
	    });
	    swiper.emit('_slideClasses', updates);
	  }
	  slidesPerViewDynamic(view, exact) {
	    if (view === void 0) {
	      view = 'current';
	    }
	    if (exact === void 0) {
	      exact = false;
	    }
	    const swiper = this;
	    const {
	      params,
	      slides,
	      slidesGrid,
	      slidesSizesGrid,
	      size: swiperSize,
	      activeIndex
	    } = swiper;
	    let spv = 1;
	    if (typeof params.slidesPerView === 'number') return params.slidesPerView;
	    if (params.centeredSlides) {
	      let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
	      let breakLoop;
	      for (let i = activeIndex + 1; i < slides.length; i += 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) breakLoop = true;
	        }
	      }
	      for (let i = activeIndex - 1; i >= 0; i -= 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) breakLoop = true;
	        }
	      }
	    } else {
	      // eslint-disable-next-line
	      if (view === 'current') {
	        for (let i = activeIndex + 1; i < slides.length; i += 1) {
	          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
	          if (slideInView) {
	            spv += 1;
	          }
	        }
	      } else {
	        // previous
	        for (let i = activeIndex - 1; i >= 0; i -= 1) {
	          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
	          if (slideInView) {
	            spv += 1;
	          }
	        }
	      }
	    }
	    return spv;
	  }
	  update() {
	    const swiper = this;
	    if (!swiper || swiper.destroyed) return;
	    const {
	      snapGrid,
	      params
	    } = swiper;
	    // Breakpoints
	    if (params.breakpoints) {
	      swiper.setBreakpoint();
	    }
	    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
	      if (imageEl.complete) {
	        processLazyPreloader(swiper, imageEl);
	      }
	    });
	    swiper.updateSize();
	    swiper.updateSlides();
	    swiper.updateProgress();
	    swiper.updateSlidesClasses();
	    function setTranslate() {
	      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
	      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
	      swiper.setTranslate(newTranslate);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    let translated;
	    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
	      setTranslate();
	      if (params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	    } else {
	      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
	        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
	        translated = swiper.slideTo(slides.length - 1, 0, false, true);
	      } else {
	        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
	      }
	      if (!translated) {
	        setTranslate();
	      }
	    }
	    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
	      swiper.checkOverflow();
	    }
	    swiper.emit('update');
	  }
	  changeDirection(newDirection, needUpdate) {
	    if (needUpdate === void 0) {
	      needUpdate = true;
	    }
	    const swiper = this;
	    const currentDirection = swiper.params.direction;
	    if (!newDirection) {
	      // eslint-disable-next-line
	      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
	    }
	    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
	      return swiper;
	    }
	    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
	    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
	    swiper.emitContainerClasses();
	    swiper.params.direction = newDirection;
	    swiper.slides.forEach(slideEl => {
	      if (newDirection === 'vertical') {
	        slideEl.style.width = '';
	      } else {
	        slideEl.style.height = '';
	      }
	    });
	    swiper.emit('changeDirection');
	    if (needUpdate) swiper.update();
	    return swiper;
	  }
	  changeLanguageDirection(direction) {
	    const swiper = this;
	    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
	    swiper.rtl = direction === 'rtl';
	    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
	    if (swiper.rtl) {
	      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
	      swiper.el.dir = 'rtl';
	    } else {
	      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
	      swiper.el.dir = 'ltr';
	    }
	    swiper.update();
	  }
	  mount(element) {
	    const swiper = this;
	    if (swiper.mounted) return true;

	    // Find el
	    let el = element || swiper.params.el;
	    if (typeof el === 'string') {
	      el = document.querySelector(el);
	    }
	    if (!el) {
	      return false;
	    }
	    el.swiper = swiper;
	    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === 'SWIPER-CONTAINER') {
	      swiper.isElement = true;
	    }
	    const getWrapperSelector = () => {
	      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
	    };
	    const getWrapper = () => {
	      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
	        const res = el.shadowRoot.querySelector(getWrapperSelector());
	        // Children needs to return slot items
	        return res;
	      }
	      return elementChildren(el, getWrapperSelector())[0];
	    };
	    // Find Wrapper
	    let wrapperEl = getWrapper();
	    if (!wrapperEl && swiper.params.createElements) {
	      wrapperEl = createElement('div', swiper.params.wrapperClass);
	      el.append(wrapperEl);
	      elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
	        wrapperEl.append(slideEl);
	      });
	    }
	    Object.assign(swiper, {
	      el,
	      wrapperEl,
	      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
	      hostEl: swiper.isElement ? el.parentNode.host : el,
	      mounted: true,
	      // RTL
	      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
	      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
	      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
	    });
	    return true;
	  }
	  init(el) {
	    const swiper = this;
	    if (swiper.initialized) return swiper;
	    const mounted = swiper.mount(el);
	    if (mounted === false) return swiper;
	    swiper.emit('beforeInit');

	    // Set breakpoint
	    if (swiper.params.breakpoints) {
	      swiper.setBreakpoint();
	    }

	    // Add Classes
	    swiper.addClasses();

	    // Update size
	    swiper.updateSize();

	    // Update slides
	    swiper.updateSlides();
	    if (swiper.params.watchOverflow) {
	      swiper.checkOverflow();
	    }

	    // Set Grab Cursor
	    if (swiper.params.grabCursor && swiper.enabled) {
	      swiper.setGrabCursor();
	    }

	    // Slide To Initial Slide
	    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
	    } else {
	      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
	    }

	    // Create loop
	    if (swiper.params.loop) {
	      swiper.loopCreate();
	    }

	    // Attach events
	    swiper.attachEvents();
	    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
	    if (swiper.isElement) {
	      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
	    }
	    lazyElements.forEach(imageEl => {
	      if (imageEl.complete) {
	        processLazyPreloader(swiper, imageEl);
	      } else {
	        imageEl.addEventListener('load', e => {
	          processLazyPreloader(swiper, e.target);
	        });
	      }
	    });
	    preload(swiper);

	    // Init Flag
	    swiper.initialized = true;
	    preload(swiper);

	    // Emit
	    swiper.emit('init');
	    swiper.emit('afterInit');
	    return swiper;
	  }
	  destroy(deleteInstance, cleanStyles) {
	    if (deleteInstance === void 0) {
	      deleteInstance = true;
	    }
	    if (cleanStyles === void 0) {
	      cleanStyles = true;
	    }
	    const swiper = this;
	    const {
	      params,
	      el,
	      wrapperEl,
	      slides
	    } = swiper;
	    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
	      return null;
	    }
	    swiper.emit('beforeDestroy');

	    // Init Flag
	    swiper.initialized = false;

	    // Detach events
	    swiper.detachEvents();

	    // Destroy loop
	    if (params.loop) {
	      swiper.loopDestroy();
	    }

	    // Cleanup styles
	    if (cleanStyles) {
	      swiper.removeClasses();
	      el.removeAttribute('style');
	      wrapperEl.removeAttribute('style');
	      if (slides && slides.length) {
	        slides.forEach(slideEl => {
	          slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
	          slideEl.removeAttribute('style');
	          slideEl.removeAttribute('data-swiper-slide-index');
	        });
	      }
	    }
	    swiper.emit('destroy');

	    // Detach emitter events
	    Object.keys(swiper.eventsListeners).forEach(eventName => {
	      swiper.off(eventName);
	    });
	    if (deleteInstance !== false) {
	      swiper.el.swiper = null;
	      deleteProps(swiper);
	    }
	    swiper.destroyed = true;
	    return null;
	  }
	  static extendDefaults(newDefaults) {
	    extend(extendedDefaults, newDefaults);
	  }
	  static get extendedDefaults() {
	    return extendedDefaults;
	  }
	  static get defaults() {
	    return defaults;
	  }
	  static installModule(mod) {
	    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
	    const modules = Swiper.prototype.__modules__;
	    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
	      modules.push(mod);
	    }
	  }
	  static use(module) {
	    if (Array.isArray(module)) {
	      module.forEach(m => Swiper.installModule(m));
	      return Swiper;
	    }
	    Swiper.installModule(module);
	    return Swiper;
	  }
	}
	Object.keys(prototypes).forEach(prototypeGroup => {
	  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
	    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
	  });
	});
	Swiper.use([Resize, Observer]);

	function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
	  if (swiper.params.createElements) {
	    Object.keys(checkProps).forEach(key => {
	      if (!params[key] && params.auto === true) {
	        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
	        if (!element) {
	          element = createElement('div', checkProps[key]);
	          element.className = checkProps[key];
	          swiper.el.append(element);
	        }
	        params[key] = element;
	        originalParams[key] = element;
	      }
	    });
	  }
	  return params;
	}

	function Navigation(_ref) {
	  let {
	    swiper,
	    extendParams,
	    on,
	    emit
	  } = _ref;
	  extendParams({
	    navigation: {
	      nextEl: null,
	      prevEl: null,
	      hideOnClick: false,
	      disabledClass: 'swiper-button-disabled',
	      hiddenClass: 'swiper-button-hidden',
	      lockClass: 'swiper-button-lock',
	      navigationDisabledClass: 'swiper-navigation-disabled'
	    }
	  });
	  swiper.navigation = {
	    nextEl: null,
	    prevEl: null
	  };
	  const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);
	  function getEl(el) {
	    let res;
	    if (el && typeof el === 'string' && swiper.isElement) {
	      res = swiper.el.querySelector(el);
	      if (res) return res;
	    }
	    if (el) {
	      if (typeof el === 'string') res = [...document.querySelectorAll(el)];
	      if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
	        res = swiper.el.querySelector(el);
	      }
	    }
	    if (el && !res) return el;
	    // if (Array.isArray(res) && res.length === 1) res = res[0];
	    return res;
	  }
	  function toggleEl(el, disabled) {
	    const params = swiper.params.navigation;
	    el = makeElementsArray(el);
	    el.forEach(subEl => {
	      if (subEl) {
	        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
	        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
	        if (swiper.params.watchOverflow && swiper.enabled) {
	          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
	        }
	      }
	    });
	  }
	  function update() {
	    // Update Navigation Buttons
	    const {
	      nextEl,
	      prevEl
	    } = swiper.navigation;
	    if (swiper.params.loop) {
	      toggleEl(prevEl, false);
	      toggleEl(nextEl, false);
	      return;
	    }
	    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
	    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
	  }
	  function onPrevClick(e) {
	    e.preventDefault();
	    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
	    swiper.slidePrev();
	    emit('navigationPrev');
	  }
	  function onNextClick(e) {
	    e.preventDefault();
	    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
	    swiper.slideNext();
	    emit('navigationNext');
	  }
	  function init() {
	    const params = swiper.params.navigation;
	    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
	      nextEl: 'swiper-button-next',
	      prevEl: 'swiper-button-prev'
	    });
	    if (!(params.nextEl || params.prevEl)) return;
	    let nextEl = getEl(params.nextEl);
	    let prevEl = getEl(params.prevEl);
	    Object.assign(swiper.navigation, {
	      nextEl,
	      prevEl
	    });
	    nextEl = makeElementsArray(nextEl);
	    prevEl = makeElementsArray(prevEl);
	    const initButton = (el, dir) => {
	      if (el) {
	        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
	      }
	      if (!swiper.enabled && el) {
	        el.classList.add(...params.lockClass.split(' '));
	      }
	    };
	    nextEl.forEach(el => initButton(el, 'next'));
	    prevEl.forEach(el => initButton(el, 'prev'));
	  }
	  function destroy() {
	    let {
	      nextEl,
	      prevEl
	    } = swiper.navigation;
	    nextEl = makeElementsArray(nextEl);
	    prevEl = makeElementsArray(prevEl);
	    const destroyButton = (el, dir) => {
	      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
	      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
	    };
	    nextEl.forEach(el => destroyButton(el, 'next'));
	    prevEl.forEach(el => destroyButton(el, 'prev'));
	  }
	  on('init', () => {
	    if (swiper.params.navigation.enabled === false) {
	      // eslint-disable-next-line
	      disable();
	    } else {
	      init();
	      update();
	    }
	  });
	  on('toEdge fromEdge lock unlock', () => {
	    update();
	  });
	  on('destroy', () => {
	    destroy();
	  });
	  on('enable disable', () => {
	    let {
	      nextEl,
	      prevEl
	    } = swiper.navigation;
	    nextEl = makeElementsArray(nextEl);
	    prevEl = makeElementsArray(prevEl);
	    if (swiper.enabled) {
	      update();
	      return;
	    }
	    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));
	  });
	  on('click', (_s, e) => {
	    let {
	      nextEl,
	      prevEl
	    } = swiper.navigation;
	    nextEl = makeElementsArray(nextEl);
	    prevEl = makeElementsArray(prevEl);
	    const targetEl = e.target;
	    if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
	      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
	      let isHidden;
	      if (nextEl.length) {
	        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
	      } else if (prevEl.length) {
	        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
	      }
	      if (isHidden === true) {
	        emit('navigationShow');
	      } else {
	        emit('navigationHide');
	      }
	      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
	    }
	  });
	  const enable = () => {
	    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
	    init();
	    update();
	  };
	  const disable = () => {
	    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
	    destroy();
	  };
	  Object.assign(swiper.navigation, {
	    enable,
	    disable,
	    update,
	    init,
	    destroy
	  });
	}

	function classesToSelector(classes) {
	  if (classes === void 0) {
	    classes = '';
	  }
	  return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
	}

	function Pagination(_ref) {
	  let {
	    swiper,
	    extendParams,
	    on,
	    emit
	  } = _ref;
	  const pfx = 'swiper-pagination';
	  extendParams({
	    pagination: {
	      el: null,
	      bulletElement: 'span',
	      clickable: false,
	      hideOnClick: false,
	      renderBullet: null,
	      renderProgressbar: null,
	      renderFraction: null,
	      renderCustom: null,
	      progressbarOpposite: false,
	      type: 'bullets',
	      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
	      dynamicBullets: false,
	      dynamicMainBullets: 1,
	      formatFractionCurrent: number => number,
	      formatFractionTotal: number => number,
	      bulletClass: `${pfx}-bullet`,
	      bulletActiveClass: `${pfx}-bullet-active`,
	      modifierClass: `${pfx}-`,
	      currentClass: `${pfx}-current`,
	      totalClass: `${pfx}-total`,
	      hiddenClass: `${pfx}-hidden`,
	      progressbarFillClass: `${pfx}-progressbar-fill`,
	      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
	      clickableClass: `${pfx}-clickable`,
	      lockClass: `${pfx}-lock`,
	      horizontalClass: `${pfx}-horizontal`,
	      verticalClass: `${pfx}-vertical`,
	      paginationDisabledClass: `${pfx}-disabled`
	    }
	  });
	  swiper.pagination = {
	    el: null,
	    bullets: []
	  };
	  let bulletSize;
	  let dynamicBulletIndex = 0;
	  const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);
	  function isPaginationDisabled() {
	    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
	  }
	  function setSideBullets(bulletEl, position) {
	    const {
	      bulletActiveClass
	    } = swiper.params.pagination;
	    if (!bulletEl) return;
	    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
	    if (bulletEl) {
	      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
	      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
	      if (bulletEl) {
	        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
	      }
	    }
	  }
	  function onBulletClick(e) {
	    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
	    if (!bulletEl) {
	      return;
	    }
	    e.preventDefault();
	    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
	    if (swiper.params.loop) {
	      if (swiper.realIndex === index) return;
	      const realIndex = swiper.realIndex;
	      const newSlideIndex = swiper.getSlideIndexByData(index);
	      const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);
	      const loopFix = dir => {
	        const indexBeforeLoopFix = swiper.activeIndex;
	        swiper.loopFix({
	          direction: dir,
	          activeSlideIndex: newSlideIndex,
	          slideTo: false
	        });
	        const indexAfterFix = swiper.activeIndex;
	        if (indexBeforeLoopFix === indexAfterFix) {
	          swiper.slideToLoop(realIndex, 0, false, true);
	        }
	      };
	      if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {
	        loopFix(newSlideIndex > currentSlideIndex ? 'next' : 'prev');
	      } else if (swiper.params.centeredSlides) {
	        const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
	        if (newSlideIndex < Math.floor(slidesPerView / 2)) {
	          loopFix('prev');
	        }
	      }
	      swiper.slideToLoop(index);
	    } else {
	      swiper.slideTo(index);
	    }
	  }
	  function update() {
	    // Render || Update Pagination bullets/items
	    const rtl = swiper.rtl;
	    const params = swiper.params.pagination;
	    if (isPaginationDisabled()) return;
	    let el = swiper.pagination.el;
	    el = makeElementsArray(el);
	    // Current/Total
	    let current;
	    let previousIndex;
	    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	    if (swiper.params.loop) {
	      previousIndex = swiper.previousRealIndex || 0;
	      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
	    } else if (typeof swiper.snapIndex !== 'undefined') {
	      current = swiper.snapIndex;
	      previousIndex = swiper.previousSnapIndex;
	    } else {
	      previousIndex = swiper.previousIndex || 0;
	      current = swiper.activeIndex || 0;
	    }
	    // Types
	    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
	      const bullets = swiper.pagination.bullets;
	      let firstIndex;
	      let lastIndex;
	      let midIndex;
	      if (params.dynamicBullets) {
	        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
	        el.forEach(subEl => {
	          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
	        });
	        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
	          dynamicBulletIndex += current - (previousIndex || 0);
	          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
	            dynamicBulletIndex = params.dynamicMainBullets - 1;
	          } else if (dynamicBulletIndex < 0) {
	            dynamicBulletIndex = 0;
	          }
	        }
	        firstIndex = Math.max(current - dynamicBulletIndex, 0);
	        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
	        midIndex = (lastIndex + firstIndex) / 2;
	      }
	      bullets.forEach(bulletEl => {
	        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
	        bulletEl.classList.remove(...classesToRemove);
	      });
	      if (el.length > 1) {
	        bullets.forEach(bullet => {
	          const bulletIndex = elementIndex(bullet);
	          if (bulletIndex === current) {
	            bullet.classList.add(...params.bulletActiveClass.split(' '));
	          } else if (swiper.isElement) {
	            bullet.setAttribute('part', 'bullet');
	          }
	          if (params.dynamicBullets) {
	            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
	              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
	            }
	            if (bulletIndex === firstIndex) {
	              setSideBullets(bullet, 'prev');
	            }
	            if (bulletIndex === lastIndex) {
	              setSideBullets(bullet, 'next');
	            }
	          }
	        });
	      } else {
	        const bullet = bullets[current];
	        if (bullet) {
	          bullet.classList.add(...params.bulletActiveClass.split(' '));
	        }
	        if (swiper.isElement) {
	          bullets.forEach((bulletEl, bulletIndex) => {
	            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
	          });
	        }
	        if (params.dynamicBullets) {
	          const firstDisplayedBullet = bullets[firstIndex];
	          const lastDisplayedBullet = bullets[lastIndex];
	          for (let i = firstIndex; i <= lastIndex; i += 1) {
	            if (bullets[i]) {
	              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
	            }
	          }
	          setSideBullets(firstDisplayedBullet, 'prev');
	          setSideBullets(lastDisplayedBullet, 'next');
	        }
	      }
	      if (params.dynamicBullets) {
	        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
	        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
	        const offsetProp = rtl ? 'right' : 'left';
	        bullets.forEach(bullet => {
	          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
	        });
	      }
	    }
	    el.forEach((subEl, subElIndex) => {
	      if (params.type === 'fraction') {
	        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {
	          fractionEl.textContent = params.formatFractionCurrent(current + 1);
	        });
	        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {
	          totalEl.textContent = params.formatFractionTotal(total);
	        });
	      }
	      if (params.type === 'progressbar') {
	        let progressbarDirection;
	        if (params.progressbarOpposite) {
	          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
	        } else {
	          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
	        }
	        const scale = (current + 1) / total;
	        let scaleX = 1;
	        let scaleY = 1;
	        if (progressbarDirection === 'horizontal') {
	          scaleX = scale;
	        } else {
	          scaleY = scale;
	        }
	        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
	          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
	          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
	        });
	      }
	      if (params.type === 'custom' && params.renderCustom) {
	        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
	        if (subElIndex === 0) emit('paginationRender', subEl);
	      } else {
	        if (subElIndex === 0) emit('paginationRender', subEl);
	        emit('paginationUpdate', subEl);
	      }
	      if (swiper.params.watchOverflow && swiper.enabled) {
	        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
	      }
	    });
	  }
	  function render() {
	    // Render Container
	    const params = swiper.params.pagination;
	    if (isPaginationDisabled()) return;
	    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	    let el = swiper.pagination.el;
	    el = makeElementsArray(el);
	    let paginationHTML = '';
	    if (params.type === 'bullets') {
	      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
	        numberOfBullets = slidesLength;
	      }
	      for (let i = 0; i < numberOfBullets; i += 1) {
	        if (params.renderBullet) {
	          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
	        } else {
	          // prettier-ignore
	          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
	        }
	      }
	    }
	    if (params.type === 'fraction') {
	      if (params.renderFraction) {
	        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
	      } else {
	        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
	      }
	    }
	    if (params.type === 'progressbar') {
	      if (params.renderProgressbar) {
	        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
	      } else {
	        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
	      }
	    }
	    swiper.pagination.bullets = [];
	    el.forEach(subEl => {
	      if (params.type !== 'custom') {
	        subEl.innerHTML = paginationHTML || '';
	      }
	      if (params.type === 'bullets') {
	        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
	      }
	    });
	    if (params.type !== 'custom') {
	      emit('paginationRender', el[0]);
	    }
	  }
	  function init() {
	    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
	      el: 'swiper-pagination'
	    });
	    const params = swiper.params.pagination;
	    if (!params.el) return;
	    let el;
	    if (typeof params.el === 'string' && swiper.isElement) {
	      el = swiper.el.querySelector(params.el);
	    }
	    if (!el && typeof params.el === 'string') {
	      el = [...document.querySelectorAll(params.el)];
	    }
	    if (!el) {
	      el = params.el;
	    }
	    if (!el || el.length === 0) return;
	    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
	      el = [...swiper.el.querySelectorAll(params.el)];
	      // check if it belongs to another nested Swiper
	      if (el.length > 1) {
	        el = el.filter(subEl => {
	          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
	          return true;
	        })[0];
	      }
	    }
	    if (Array.isArray(el) && el.length === 1) el = el[0];
	    Object.assign(swiper.pagination, {
	      el
	    });
	    el = makeElementsArray(el);
	    el.forEach(subEl => {
	      if (params.type === 'bullets' && params.clickable) {
	        subEl.classList.add(...(params.clickableClass || '').split(' '));
	      }
	      subEl.classList.add(params.modifierClass + params.type);
	      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
	      if (params.type === 'bullets' && params.dynamicBullets) {
	        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
	        dynamicBulletIndex = 0;
	        if (params.dynamicMainBullets < 1) {
	          params.dynamicMainBullets = 1;
	        }
	      }
	      if (params.type === 'progressbar' && params.progressbarOpposite) {
	        subEl.classList.add(params.progressbarOppositeClass);
	      }
	      if (params.clickable) {
	        subEl.addEventListener('click', onBulletClick);
	      }
	      if (!swiper.enabled) {
	        subEl.classList.add(params.lockClass);
	      }
	    });
	  }
	  function destroy() {
	    const params = swiper.params.pagination;
	    if (isPaginationDisabled()) return;
	    let el = swiper.pagination.el;
	    if (el) {
	      el = makeElementsArray(el);
	      el.forEach(subEl => {
	        subEl.classList.remove(params.hiddenClass);
	        subEl.classList.remove(params.modifierClass + params.type);
	        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
	        if (params.clickable) {
	          subEl.classList.remove(...(params.clickableClass || '').split(' '));
	          subEl.removeEventListener('click', onBulletClick);
	        }
	      });
	    }
	    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
	  }
	  on('changeDirection', () => {
	    if (!swiper.pagination || !swiper.pagination.el) return;
	    const params = swiper.params.pagination;
	    let {
	      el
	    } = swiper.pagination;
	    el = makeElementsArray(el);
	    el.forEach(subEl => {
	      subEl.classList.remove(params.horizontalClass, params.verticalClass);
	      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
	    });
	  });
	  on('init', () => {
	    if (swiper.params.pagination.enabled === false) {
	      // eslint-disable-next-line
	      disable();
	    } else {
	      init();
	      render();
	      update();
	    }
	  });
	  on('activeIndexChange', () => {
	    if (typeof swiper.snapIndex === 'undefined') {
	      update();
	    }
	  });
	  on('snapIndexChange', () => {
	    update();
	  });
	  on('snapGridLengthChange', () => {
	    render();
	    update();
	  });
	  on('destroy', () => {
	    destroy();
	  });
	  on('enable disable', () => {
	    let {
	      el
	    } = swiper.pagination;
	    if (el) {
	      el = makeElementsArray(el);
	      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
	    }
	  });
	  on('lock unlock', () => {
	    update();
	  });
	  on('click', (_s, e) => {
	    const targetEl = e.target;
	    const el = makeElementsArray(swiper.pagination.el);
	    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
	      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
	      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
	      if (isHidden === true) {
	        emit('paginationShow');
	      } else {
	        emit('paginationHide');
	      }
	      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
	    }
	  });
	  const enable = () => {
	    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
	    let {
	      el
	    } = swiper.pagination;
	    if (el) {
	      el = makeElementsArray(el);
	      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
	    }
	    init();
	    render();
	    update();
	  };
	  const disable = () => {
	    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
	    let {
	      el
	    } = swiper.pagination;
	    if (el) {
	      el = makeElementsArray(el);
	      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
	    }
	    destroy();
	  };
	  Object.assign(swiper.pagination, {
	    enable,
	    disable,
	    render,
	    update,
	    init,
	    destroy
	  });
	}

	function Scrollbar(_ref) {
	  let {
	    swiper,
	    extendParams,
	    on,
	    emit
	  } = _ref;
	  const document = getDocument();
	  let isTouched = false;
	  let timeout = null;
	  let dragTimeout = null;
	  let dragStartPos;
	  let dragSize;
	  let trackSize;
	  let divider;
	  extendParams({
	    scrollbar: {
	      el: null,
	      dragSize: 'auto',
	      hide: false,
	      draggable: false,
	      snapOnRelease: true,
	      lockClass: 'swiper-scrollbar-lock',
	      dragClass: 'swiper-scrollbar-drag',
	      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
	      horizontalClass: `swiper-scrollbar-horizontal`,
	      verticalClass: `swiper-scrollbar-vertical`
	    }
	  });
	  swiper.scrollbar = {
	    el: null,
	    dragEl: null
	  };
	  function setTranslate() {
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    const {
	      scrollbar,
	      rtlTranslate: rtl
	    } = swiper;
	    const {
	      dragEl,
	      el
	    } = scrollbar;
	    const params = swiper.params.scrollbar;
	    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
	    let newSize = dragSize;
	    let newPos = (trackSize - dragSize) * progress;
	    if (rtl) {
	      newPos = -newPos;
	      if (newPos > 0) {
	        newSize = dragSize - newPos;
	        newPos = 0;
	      } else if (-newPos + dragSize > trackSize) {
	        newSize = trackSize + newPos;
	      }
	    } else if (newPos < 0) {
	      newSize = dragSize + newPos;
	      newPos = 0;
	    } else if (newPos + dragSize > trackSize) {
	      newSize = trackSize - newPos;
	    }
	    if (swiper.isHorizontal()) {
	      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
	      dragEl.style.width = `${newSize}px`;
	    } else {
	      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
	      dragEl.style.height = `${newSize}px`;
	    }
	    if (params.hide) {
	      clearTimeout(timeout);
	      el.style.opacity = 1;
	      timeout = setTimeout(() => {
	        el.style.opacity = 0;
	        el.style.transitionDuration = '400ms';
	      }, 1000);
	    }
	  }
	  function setTransition(duration) {
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
	  }
	  function updateSize() {
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    const {
	      scrollbar
	    } = swiper;
	    const {
	      dragEl,
	      el
	    } = scrollbar;
	    dragEl.style.width = '';
	    dragEl.style.height = '';
	    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
	    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
	    if (swiper.params.scrollbar.dragSize === 'auto') {
	      dragSize = trackSize * divider;
	    } else {
	      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
	    }
	    if (swiper.isHorizontal()) {
	      dragEl.style.width = `${dragSize}px`;
	    } else {
	      dragEl.style.height = `${dragSize}px`;
	    }
	    if (divider >= 1) {
	      el.style.display = 'none';
	    } else {
	      el.style.display = '';
	    }
	    if (swiper.params.scrollbar.hide) {
	      el.style.opacity = 0;
	    }
	    if (swiper.params.watchOverflow && swiper.enabled) {
	      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
	    }
	  }
	  function getPointerPosition(e) {
	    return swiper.isHorizontal() ? e.clientX : e.clientY;
	  }
	  function setDragPosition(e) {
	    const {
	      scrollbar,
	      rtlTranslate: rtl
	    } = swiper;
	    const {
	      el
	    } = scrollbar;
	    let positionRatio;
	    positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
	    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
	    if (rtl) {
	      positionRatio = 1 - positionRatio;
	    }
	    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
	    swiper.updateProgress(position);
	    swiper.setTranslate(position);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }
	  function onDragStart(e) {
	    const params = swiper.params.scrollbar;
	    const {
	      scrollbar,
	      wrapperEl
	    } = swiper;
	    const {
	      el,
	      dragEl
	    } = scrollbar;
	    isTouched = true;
	    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
	    e.preventDefault();
	    e.stopPropagation();
	    wrapperEl.style.transitionDuration = '100ms';
	    dragEl.style.transitionDuration = '100ms';
	    setDragPosition(e);
	    clearTimeout(dragTimeout);
	    el.style.transitionDuration = '0ms';
	    if (params.hide) {
	      el.style.opacity = 1;
	    }
	    if (swiper.params.cssMode) {
	      swiper.wrapperEl.style['scroll-snap-type'] = 'none';
	    }
	    emit('scrollbarDragStart', e);
	  }
	  function onDragMove(e) {
	    const {
	      scrollbar,
	      wrapperEl
	    } = swiper;
	    const {
	      el,
	      dragEl
	    } = scrollbar;
	    if (!isTouched) return;
	    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	    setDragPosition(e);
	    wrapperEl.style.transitionDuration = '0ms';
	    el.style.transitionDuration = '0ms';
	    dragEl.style.transitionDuration = '0ms';
	    emit('scrollbarDragMove', e);
	  }
	  function onDragEnd(e) {
	    const params = swiper.params.scrollbar;
	    const {
	      scrollbar,
	      wrapperEl
	    } = swiper;
	    const {
	      el
	    } = scrollbar;
	    if (!isTouched) return;
	    isTouched = false;
	    if (swiper.params.cssMode) {
	      swiper.wrapperEl.style['scroll-snap-type'] = '';
	      wrapperEl.style.transitionDuration = '';
	    }
	    if (params.hide) {
	      clearTimeout(dragTimeout);
	      dragTimeout = nextTick(() => {
	        el.style.opacity = 0;
	        el.style.transitionDuration = '400ms';
	      }, 1000);
	    }
	    emit('scrollbarDragEnd', e);
	    if (params.snapOnRelease) {
	      swiper.slideToClosest();
	    }
	  }
	  function events(method) {
	    const {
	      scrollbar,
	      params
	    } = swiper;
	    const el = scrollbar.el;
	    if (!el) return;
	    const target = el;
	    const activeListener = params.passiveListeners ? {
	      passive: false,
	      capture: false
	    } : false;
	    const passiveListener = params.passiveListeners ? {
	      passive: true,
	      capture: false
	    } : false;
	    if (!target) return;
	    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
	    target[eventMethod]('pointerdown', onDragStart, activeListener);
	    document[eventMethod]('pointermove', onDragMove, activeListener);
	    document[eventMethod]('pointerup', onDragEnd, passiveListener);
	  }
	  function enableDraggable() {
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    events('on');
	  }
	  function disableDraggable() {
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
	    events('off');
	  }
	  function init() {
	    const {
	      scrollbar,
	      el: swiperEl
	    } = swiper;
	    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
	      el: 'swiper-scrollbar'
	    });
	    const params = swiper.params.scrollbar;
	    if (!params.el) return;
	    let el;
	    if (typeof params.el === 'string' && swiper.isElement) {
	      el = swiper.el.querySelector(params.el);
	    }
	    if (!el && typeof params.el === 'string') {
	      el = document.querySelectorAll(params.el);
	    } else if (!el) {
	      el = params.el;
	    }
	    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
	      el = swiperEl.querySelector(params.el);
	    }
	    if (el.length > 0) el = el[0];
	    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
	    let dragEl;
	    if (el) {
	      dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);
	      if (!dragEl) {
	        dragEl = createElement('div', swiper.params.scrollbar.dragClass);
	        el.append(dragEl);
	      }
	    }
	    Object.assign(scrollbar, {
	      el,
	      dragEl
	    });
	    if (params.draggable) {
	      enableDraggable();
	    }
	    if (el) {
	      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
	    }
	  }
	  function destroy() {
	    const params = swiper.params.scrollbar;
	    const el = swiper.scrollbar.el;
	    if (el) {
	      el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
	    }
	    disableDraggable();
	  }
	  on('init', () => {
	    if (swiper.params.scrollbar.enabled === false) {
	      // eslint-disable-next-line
	      disable();
	    } else {
	      init();
	      updateSize();
	      setTranslate();
	    }
	  });
	  on('update resize observerUpdate lock unlock', () => {
	    updateSize();
	  });
	  on('setTranslate', () => {
	    setTranslate();
	  });
	  on('setTransition', (_s, duration) => {
	    setTransition(duration);
	  });
	  on('enable disable', () => {
	    const {
	      el
	    } = swiper.scrollbar;
	    if (el) {
	      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
	    }
	  });
	  on('destroy', () => {
	    destroy();
	  });
	  const enable = () => {
	    swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
	    if (swiper.scrollbar.el) {
	      swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
	    }
	    init();
	    updateSize();
	    setTranslate();
	  };
	  const disable = () => {
	    swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
	    if (swiper.scrollbar.el) {
	      swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
	    }
	    destroy();
	  };
	  Object.assign(swiper.scrollbar, {
	    enable,
	    disable,
	    updateSize,
	    setTranslate,
	    init,
	    destroy
	  });
	}

	var Slider = {
	    oninit: function (_a) {
	        var state = _a.state, attrs = _a.attrs;
	        if (!attrs.name) {
	            throw new Error('No classname for Swiper instance given.');
	        }
	        else if (!attrs.slides || attrs.slides.length === 0) {
	            throw new Error('Slider has no slides to present.');
	        }
	        state.options = {
	            pagination: {
	                renderBullet: function (index, className) {
	                    return '<span class="' + className + '">' + (index + 1) + '</span>';
	                },
	                clickable: true,
	                el: ".swiper-pagination-".concat(attrs.name),
	            },
	            navigation: {
	                nextEl: ".swiper-button-next-".concat(attrs.name),
	                prevEl: ".swiper-button-prev-".concat(attrs.name),
	            },
	            scrollbar: {
	                el: ".swiper-scrollbar-".concat(attrs.name),
	            },
	            modules: [
	                Scrollbar,
	                Navigation,
	                Pagination,
	            ],
	            longSwipes: false,
	            shortSwipes: true,
	            simulateTouch: false,
	            allowTouchMove: false,
	        };
	    },
	    oncreate: function (_a) {
	        var state = _a.state, attrs = _a.attrs;
	        if (attrs.options) {
	            state.options = Object.assign(state.options, attrs.options);
	        }
	        state.slider = new Swiper(".".concat(attrs.name), state.options);
	    },
	    view: function (_a) {
	        var attrs = _a.attrs;
	        var slides = attrs.slides, name = attrs.name;
	        return (m$1("div", { class: "swiper ".concat(name) },
	            m$1("div", { class: "swiper-wrapper" }, slides.map(function (slide, index) {
	                return m$1("div", { class: "swiper-slide", key: "slide-".concat(index) }, slide);
	            })),
	            m$1("div", { class: "swiper-scrollbar swiper-scrollbar-".concat(name) }),
	            m$1("div", { class: "swiper-button-prev swiper-button-prev-".concat(name) },
	                m$1("i", { class: "fas fa-arrow-circle-left" })),
	            m$1("div", { class: "swiper-button-next swiper-button-next-".concat(name) },
	                m$1("i", { class: "fas fa-arrow-circle-right" })),
	            m$1("div", { class: "swiper-pagination swiper-pagination-".concat(name) })));
	    }
	};

	var Slide = m$1("article", { "class": "slide" }, "Slide Content");
	var Root = {
	    view: function () {
	        return ([
	            m$1("p", null,
	                m$1("strong", null, "I. Slider")),
	            m$1(Slider, { name: 'swiper-1', slides: [Slide, Slide, Slide] }),
	            m$1("div", { class: "pv4" }),
	            m$1("p", null,
	                m$1("strong", null, "II. Slider auf selber Seite")),
	            m$1(Slider, { name: 'swiper-2', slides: [Slide, Slide, Slide] }),
	        ]);
	    },
	};
	m$1.mount(document.querySelector('.example-app'), Root);

})();
//# sourceMappingURL=demo.min.js.map
